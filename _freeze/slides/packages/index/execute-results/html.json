{
  "hash": "ddbe1f85797e5e7f23e0ff76be3e7617",
  "result": {
    "markdown": "---\ntitle: \"R packages\"\nauthor: \"Sebastian DiLorenzo\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n## {visibility=\"hidden\"}\n\n\n::: {.cell}\n\n:::\n\n\n# Overview\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n- What is an R package?\n- Possible package states\n<!-- * [Repositories](#)Include? -->\n- Package structure:\n    - Code | `r/`\n    - Metadata | `DESCRIPTION`\n    - Documentation | `man/`\n    - Vignettes\n    - Import & Export | `NAMESPACE`\n    - Data | `data/`\n    - Tests | `tests/`\n    - Compiled code | `src/`\n<!--    + [Installed files | `inst/`](#) Include? -->     \n<!-- * [Testing](#)  Include? -->\n- CRAN and `R CMD check`\n- Rstudio and Github\n<!-- * [Package website | `pkgdown`](#)  Include? -->\n:::\n\n::: {.column width=\"50%\"}\n![](assets/rpkg_book.png){width=\"60%\"}  \n[[http://r-pkgs.had.co.nz/]{.smaller}](http://r-pkgs.had.co.nz/])\n:::\n::::\n\n::: {.notes}\nAn overview of the topics I will discuss during the lecture.\n\"What is an R package\" is what should come to mind when thinking an R package.\nIn \"Possible package states\" I will talk about the the different forms we can find R packages in, such as development and installed.\nIn package structure I will walk through each of the folders usually included in an R package.\n\"git, github, Rstudio and you\" is about why git, github and rstudio are good working environments for package development.\nAnd in \"Cran and \"R CMD check\"\" I will talk about tools to check your package and the requirements and pros/cons of submitting it CRAN.\n:::\n\n## What is an R package?\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](assets/tree_rpkg_mini.png){width=\"60%\"}\n:::\n\n::: {.column width=\"50%\"}\n- A strict and connected folder and file structure\n:::\n::::\n\n::: {.notes}\nYou can think of an R package under development as a folder and file structure with some predetermined names and connectivity. So really, a package is more about knowing how to organise code and other files than being a good R programmer. There are also some differences in how you write code that is intended to be used for a package than a script for analysis for example. But I will get back to this.  The minimal required package has a DESCRIPTION, a NAMESPACE an R folder for code and here we also see a R project file created by Rstudio which is not required.\n:::\n\n## What is an R package?\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](assets/tree_rpkg_mini.png){width=\"60%\"}\n![](assets/tree_rpkg.png){width=\"60%\"}\n:::\n\n::: {.column width=\"50%\"}\n- A strict and connected folder and file structure\n:::\n::::\n\n::: {.notes}\nThere are many additional components you can add to the package, more than are shown here, I will go through the major parts of these in this lecture. So what are R packages for?\n:::\n\n## What is an R package?\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](assets/tree_rpkg_mini.png){width=\"60%\"}\n![](assets/tree_rpkg.png){width=\"60%\"}\n:::\n\n::: {.column width=\"50%\"}\n- A strict and connected folder and file structure\n- Sharing code\n- Improved quality and rigor\n    - Documentation\n    - Tests\n    - Examples\n- Efficiency\n- Improvability\n- Reproducibility\n:::\n::::\n\n::: {.notes}\nR packages are for sharing code in a way where others can use it. It also forces the author to include elements which can improve the quality of the code, such as documentation, examples and tests. This is a benefit no matter if the package is intended for other users or not. It really helps when coming back to your own code at a later date. Once you get better at writing packages it may even be more time efficient to write a package even if you are not going to share it.\n:::\n\n::: {.notes}\nFinally; At the moment there is much talk about the reproducibility crisis and creating code in this way is definitely in line with good reproducibility.\n:::\n\n## Package naming\n\n- A name that describes your packages function\n    - Letters, numbers and periods\n    - Must start with letter\n    - Cannot end with period\n- Make it googleable\n- Check that it doesn't already exist!\n    - CRAN\n    - github\n    - Bioconductor\n\n## Package states\n\nThere are five states a package can exist in:\n\n- Source\n- Bundled\n- Binary\n- Installed\n- In-memory\n\n::: {.notes}\nTo help understand what's going on with a package it is useful to know the possible states a package can be in.\n:::\n\n## Package states {.incremental}\n\n### Source\n\nThe development version of your package. The collection of files on your computer.\n\n### Bundled\n\n- A compressed, **tar.gz** source package with vignettes built\n- **.Rbuildignore** files are excluded\n    - Useful for data for example\n\n::: {.notes}\nWe will get to what vignettes are.\n:::\n\n### Binary\n\n- A bundle that is built for a certain architecture\n- Parsed format, skipping the development tools needed to take the package between source and being interpretable by R\n\n::: {.notes}\nLike the bundled package except that if you uncompressed it doesnt look like the source package. This is because it is built for a certain architecture, or operating system.\n:::\n\n## Package states {.incremental}\n\n### Installed\n\n- A binary package decompressed into a package library for R\n    - The package library is the directory or directories where `library(packagename)` searches\n        - `.libPaths()`\n\n### In-memory\n\nWhen you use a package, it is in memory. When developing, a package does not have to be installed to be in memory.\n\n- `packagename::function()` loads packagename\n\n- `library(packagename)` loads and attaches packagename\n\n::: {.notes}\nThere is a subtle difference between loading a package into memory to be able to use the functions and also attaching it to the search path so you can use the functions without writing packagename::function(). When you are developing a package it is good to avoid using library and attaching a package because it makes it clearer which package you want the method to come from and having your package attach another package to its search path can mess up your users scripts.\n:::\n\n## Package states\n\n![](assets/installation.png)  \n[[http://r-pkgs.had.co.nz/package.html]{.smaller}](http://r-pkgs.had.co.nz/package.html)\n\n\n::: {.notes}\nThis image is from Hadleys great introduction to developing packages and I think it illustrates very well how when you run install.packages() from CRAN what is really happening is that it determining what operating system you are on, getting the correct binary version of the package and then, on your device, running R CMD install to put it in your R library. From there you can use the library() command, or not if you are developing, to take it into memory. Whereas if you use type = \"source\" it will not infer your architecture and grab the bundled source if you will instead. This process will demand that you have the tools on your computer to build the correct binary and install.\n:::\n\n## R/\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n![](assets/tree_rpkg.png){width=\"80%\"}\n:::\n::::\n\n::: {.notes}\nNow we will start to go through the folders and files in a package to see how they interact, what belongs where and what they do.\n:::\n\n## R/\n\n:::: {.columns}\n::: {.column width=\"40%\"}\n![](assets/tree_rpkg.png){width=\"80%\" style=\"opacity:0.5;\"}\n![](assets/tree_r.png){width=\"80%\"}\n:::\n\n::: {.column width=\"60%\"}\n- Code\n    - Large functions in their own R files\n    - Utility functions, that your package uses, in one R file\n- Bad code\n    - `library()`, `require()`, `source()`\n    - `options()`, `par()`\n:::\n::::\n\n::: {.notes}\nThe first folder is the R/ folder. This is where your R code lives. You should try to keep it organized with functions that your user will be using grouped in some R files, and your utility functions in their own R file. Utility functions are functions that you dont expect your user to run, rather they are used by your main functions. If a function doesnt fit in a group or is very large, it can have its own R file, but each function should not have their own R file.\nYou should avoid using functions in your code that modify the environment of your user. For example if you use library() it will attach the package functions of your user, perhaps getting in the way of other functions he was already using elsewhere. It is better to be explicit then and only load a package into memory. If you change options() or par() settings you should revert them before ending the function so your users environment isnt changed.\n:::\n\n## DESCRIPTION\n\n![](assets/DESCRIPTION.png)\n\n::: {.notes}\nNow lets look at the DESCRIPTION file. This file handles the metadata of your package. You can change the name of your package in the title here but remember then to change the folder of your package as they should match.\n:::\n\n. . .\n\n:::: {.columns}\n::: {.column width=\"30%\"}\n\n- Title\n    - 65 characters, no punctuation\n- Version\n    - The version of the package\n- Description\n    - One paragraph\n\n::: {.aside}\n\n[* ]{.bold}required\n\n:::\n:::\n\n::: {.column width=\"70%\"}\n\n- Authors@R\n    - Roles\n        - **cre***: Creator or maintainer.\n        - **aut***: Author or authors, that have made significant contributions.\n        - **ctb**: Contributors, have made smaller contributions.\n        - **cph**: Copyright holder. Used if copyright is held by someone other than author, typically company.\n\n:::\n::::\n\n::: {.notes}\n\nNot all of the fields in DESCRIPTION are important unless you plan to distribute you package to other users.\nThe title of you package should be a short description, no more than 65 characters. I'll talk more in a second about version number recommendations but for now it is enough to say that it is the version of your package and you decide what version your package is in. The author can be one or many people, with names, emails and roles. Every package must have a creator or maintainer and any number of authors, the rest is optional.\n\n:::\n\n## DESCRIPTION\n\n![](assets/DESCRIPTION.png)\n\n:::: {.columns}\n::: {.column width=\"30%\"}\n\n- Depends & Imports\n    - Packages and versions that your package needs\n    - Versions are optional\n    - Depends: Attaches!\n    - Imports: Loads!\n- Suggests\n    - Added functionality\n\n:::\n\n::: {.column width=\"70%\"}\n\n- LazyData\n    - Datasets occupy no memory until loaded\n- License\n    - Can be a file; LICENSE\n    - Influences permissions of who can distribute and modify in what way\n    - Most common; MIT, GPL-3, CC0.\n    - https://tldrlegal.com/\n    - CRAN requires a license\n\n:::\n::::\n\n::: {.notes}\n\nThe Depends and Imports fields of DESCRIPTION handles what packages, and optionally what versions of packages, your package needs to work. The big difference here is that depends attaches the functions, something that is generally frowned upon for packages, and imports loads them, making them available for use. So usually you will see Depends on R version and most other packages in Imports.\nSuggests isnt packages that your package needs to function properly but with those packages there can be added functionality. For example a package can create a plot using base R plotting tools but you have built in that if ggplot2 is available create pretties plots instead.\nLazyData is a special function which should be true which states that any datasets included in your package should not take any memory until they are used.\nThe license of your package should reflect who and how your package should be used or modified. If the license is longer than just a standard abbreviation it can be a file, called LICENSE.\n\n:::\n\n## Versioning\n\n[0.0.0.9000]{.largest .center}\n\n. . .\n\n[major.minor.patch.dev]{.larger .center}\n\n- Major\n  - Large changes, not always backwards compatible\n  - Usually 1 upon first release out of dev\n- Minor\n  - Bug fixes & new features. Most common\n- Patch\n  - Small bugfixes, no new features.\n- Dev\n  - Only used while under development\n  - Always starts at 9000\n\n::: {.notes}\nWether you are developing your package, or updating and adding to a released package, it is good to change the version numbers in your DESCRIPTION file to reflect the changes. The four numbers reflect the kind of change that you have made to the package. Dev should be removed from the package upon release.\n:::\n\n## man/\n\n:::: {.columns}\n::: {.column width=\"30%\"}\n\n![](assets/tree_rpkg.png){width=\"80%\"}\n\n:::{.small}\n\n*call_me.R*\n\n```\n#' Output \"Call me \" followed by input.\n#'\n#' @param x A character or characters.\n#' @return The string \"Call me \" and \\code{x}. I'll write this\n#'    to display how to section with tags.\n#' @examples\n#' call_me(\"Maeby\")\ncall_me <- function(x) {\n  paste(\"Call me \", x, sep=\"\")\n}\n```\n\n:::\n\n:::\n\n::: {.notes}\n\nDocumentation of your functions is important for helping users know how to use your package, and also for yourself when you come back to the package. The documentation is in the man/ directory in \"R documentation\", or Rd files. They contain the information you see when you call ?function. While you can write these by hand it is easier and handsomer to have the package roxygen2 generate them for you.\n\n:::\n\n::: {.column width=\"70%\"}\n\n- `Roxygen2`\n  - ?function\n  - Comment block, `#'`, preceding a function\n  - Tags, `@tags`, map values\n  - No tag for introduction\n      - title*\n      - description\n      - details\n  - Special characters `@\\%`, escape with `\\`\n\n:::\n::::\n\n::: {.notes}\nRoxygen2 works with special comment blocks in your code, directly before the function you are documenting, to create the Rd files. So you are actually writing your documentation in the same place as your code, the .R file, which is easier than going to another file and updating it. It also reminds you as you update your code to update the documentation in a natural way, and roxygen even deducts some information by itself so it is faster to write documentation.\nHere is an example function call_me.R with the roxygen2 documentation block preceding it. The first line will become the title and also the description if none is given. @param documents the parameter x, @return lets us know what the function returns, and notice the indentation here which I have added to signify how to add multiple rows of text and have them belong together. @examples shows one or many example executions of the code.\n:::\n\n## man/\n\n:::: {.columns}\n::: {.column width=\"60%\"}\n\n*call_me.R*\n\n```\n#' Output \"Call me \" followed by input.\n#'\n#' @param x A character or characters.\n#' @return The string \"Call me \" and \\code{x}. I'll write this\n#'    to display how to section with tags.\n#' @examples\n#' call_me(\"Maeby\")\ncall_me <- function(x) {\n  paste(\"Call me \", x, sep=\"\")\n}\n```\n\n*call_me.Rd*\n\n```\n% Generated by roxygen2: do not edit by hand\n% Please edit documentation in R/call_me.R\n\\name{call_me}\n\\alias{call_me}\n\\title{Output \"Call me \" followed by input.}\n\\usage{\ncall_me(x)\n}\n\\arguments{\n\\item{x}{A character or characters.}\n}\n\\value{\nThe string \"Call me \" and \\code{x}. I'll write this\n   to display how to section with tags.\n}\n\\description{\nOutput \"Call me \" followed by input.\n}\n\\examples{\ncall_me(\"Maeby\")\n}\n```\n]{.small}\n\n:::\n\n::: {.notes}\nSo when your documentation is built, roxygen takes the block information and generates a Rd file that looks like this.\n:::\n\n::: {.column width=\"40%\"}\n\n<br><br>\n`> ?call_me`\n\n![](assets/rdexample.png)\n\n:::\n::::\n\n::: {.notes}\nAnd when you do question mark the function name in R the Rd file is parsed and you get this helpful documentation that I am sure you are all familiar with. I know this is a busy slide but what I hope I have been able to convey to you is that you use the code block in the .R code file which roxygen2 parses to create the Rd file which in turn is what is read when you ask for the documentation of a function in R.\n:::\n\n## man/ for datasets\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](assets/tree_rpkg.png){width=\"80%\"}\n\n::: {.notes}\nWe will get to datasets later but while I am talking about documentation you should also document your datasets, if you have any. It is very similar to functional documentation, my dataset is the publicly available ToothGrowth dataset and I have created a R file called data.R where I will add documentation.\n:::\n:::\n\n::: {.column width=\"50%\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(ToothGrowth)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   len supp dose\n1  4.2   VC  0.5\n2 11.5   VC  0.5\n3  7.3   VC  0.5\n4  5.8   VC  0.5\n5  6.4   VC  0.5\n6 10.0   VC  0.5\n```\n:::\n:::\n\n\n<br><br>\n\n:::\n\n::: {.notes}\nHere we see the head of the ToothGrowth dataset.\n:::\n\n*data.R:*\n\n```\n#' The Effect of Vitamin C on Tooth Growth in Guinea Pigs\n#'\n#' The response is the length of odontoblasts (cells responsible for tooth growth)\n#'   in 60 guinea pigs. Each animal received one of three dose levels of vitamin C\n#'   (0.5, 1, and 2 mg/day) by one of two delivery methods, orange juice or ascorbic\n#'   acid (a form of vitamin C and coded as VC).\n#'\n#' @usage ToothGrowth\n#'\n#' @format A data frame with 60 observations on 3 variables.\n#' \\describe{\n#'   \\item{len}{Tooth length}\n#'   \\item{supp}{Supplement type (VC or OJ).}\n#'   \\item{dose}{Dose in milligrams/day}\n#' }\n#' @source \\url{https://www.elsevier.com/books/the-statistics-of-bioassay/bliss/978-1-4832-5662-7}\n\"ToothGrowth\"\n```\n\n::: {.notes}\nAnd here we see the documentation, which I have put in data.R. Just like previously this is then parsed by roxygen2 when I give the command and ToothGrowth.Rd is created. First title, then description, the usage in this case is just the dataset, and the @format describes the data, not @params that described our functions parameters. At the very end we see just the name of the dataset, which lives in ToothGrowth.RData.\n:::\n::::\n\n## vignettes/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n- A more complete guide to your package\n  - For user/you\n  - Examples and use cases\n- `knitr` & `rmarkdown`\n  - `knitr`: add r code to markdown\n- `vignettes/package-vignette.Rmd`\n\n```\nusethis::use_vignette(\"typicalr-vignette\")\n```\n\n::: {.notes}\nVignettes are a long-form guide, or manual, to the package that details what the functions in the package can do. It can also show and give examples of what the package is designed to do, using multiple functions in sequence. If functional documentation shows just a part, think of the vignette as a book chapter showing what your package can do. It can look very different if you intend it for your users or for yourself to read at a later date. You can use many things to create the vignette, but like with roxygen2 probably the easiest is to use knitr and rmarkdown.\n:::\n\n:::\n\n::: {.column width=\"50%\"}\n\n*typicalr-vignette.Rmd*\n\n```\n  ---\n  title: \"Vignette Title\"\n  author: \"Vignette Author\"\n  date: \"2023-03-11\"\n  output: rmarkdown::html_vignette\n  vignette: >\n    %\\VignetteIndexEntry{Vignette Title}\n    %\\VignetteEngine{knitr::rmarkdown}\n    %\\VignetteEncoding{UTF-8}\n  ---\n```\n:::\n::::\n\n::: {.notes}\nWhat we are seeing here is the top metadata of a template for a vignette that I created using usethis::use_vignette(\"typicalr-vignette\") which created typicalr-vignette.Rmd and the vignettes/ directory. It also edits DESCRIPTION, adding knitr and rmarkdown to suggests, and adding VignetteBuilder: knitr. You are free to edit any part of the rmarkdown file but should not change the structure of the metadata. Only add the title in both places where it says \"Vignette title\" and your name as author. You can also change the output to pdf vignette for example.\nLuckily you have already gone through rmarkdown, so we dont need to talk about that, =).\n:::\n\n## vignettes/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n- A more complete guide to your package\n  - For user/you\n  - Examples and use cases\n- `knitr` & `rmarkdown`\n  - `knitr`: add r code to markdown\n- `vignettes/package-vignette.Rmd`\n\n```\nusethis::use_vignette(\"typicalr-vignette\")\n```\n:::\n::: {.column width=\"50%\"}\n\n*typicalr-vignette.Rmd*\n\n```\n  ---\n  title: \"typicalr\"\n  author: \"Sebastian DiLorenzo\"\n  date: \"2023-03-11\"\n  output: rmarkdown::html_vignette\n  vignette: >\n    %\\VignetteIndexEntry{typicalr}\n    %\\VignetteEngine{knitr::rmarkdown}\n    %\\VignetteEncoding{UTF-8}\n  ---\n```\n:::\n::::\n\n## NAMESPACE\n\n[package1 names &emsp; &emsp; &emsp; &emsp; package2 names]{.center}\n\n![](assets/venn.png){fig-align=\"center\"}\n\n::: {.notes}\nThe namespace makes sure your package works well with other packages, so it is mostly important for submitting to repository, CRAN. It makes sure your code and the code of other packages doesnt interfere with eachother. I like to think of it as a venn diagram, where each circle is a space filled with names. What the namespace does is remove the overlap, so if your function uses a function from package1, it wont accidentally use a function with the same name from package2. It does this by specifying which space a function should look for the name of a function it needs.\n:::\n\n. . .\n\n- `@imports` and `@importsFrom`\n  - Defines how/where a function in one package finds a function in another\n  - `@imports` *pkg*\n  - `@importsFrom` *pkg function*\n- `@export`\n  - Defines which functions are available to user\n  - Do not export data\n\n::: {.notes}\nIt does this using imports and exports.\nLike the other documentation, we can use roxygen2 to create our namespace. Using the imports tag, it doesnt matter if our user has loaded a package with a function with the same name as one of our functions are using, because our function will know to use the one specified in imports. Exports helps by saying that only these functions of my package are available outside. If you export all your functions, it increases the risk of being incompatible with other packages, so good practice is to export as few as possible.\nIf you are not going to share your package, just export every function.\n:::\n\n## NAMESPACE\n\n[*call_me.R:*]{.small}\n\n```\n#' Output \"Call me \" followed by input.\n#'\n#' @param x A character or characters.\n#' @return The string \"Call me \" and \\code{x}. I'll write this\n#'    to display how to section with tags.\n#' @examples\n#' call_me(\"Maeby\")\n#' @export\ncall_me <- function(x) {\n  paste(\"Call me \",x,sep=\"\")\n}\n```\n\n[*utility.R:*]{.small}\n\n```\n#' @import knitr\nNULL\n```\n\n::: {.notes}\nRevisiting call_me.R, I have now added the @export tag, and in the utility.R I have @import knitr, just as an example, using the NULL object since there has to be something there.\n:::\n\n. . .\n\n*NAMESPACE:*\n\n```\n# Generated by roxygen2: do not edit by hand\n\nexport(call_me)\nimport(knitr)\n```\n\n::: {.notes}\nSo when I run devtools::document(), just like when we generated the other documentation, this will generate the NAMESPACE for us. Notice that this is a very minimal example and roxygen2 actually looks at what you are exporting so there are added benefits here where you are just writing @export but roxygen2 is correctly exporting it as a S3 or S4 class etc.\n:::\n\n## NAMESPACE\n\n[Import in **DESCRIPTION** and in **NAMESPACE**!?]{.large .center}\n\n::: {.notes}\nA final note on the namespace is that at a glance we are now importing packages both in the DESCRIPTION and in the NAMESPACE. This is more an accident of naming as they are doing a bit different things.\n:::\n\n. . .\n\n- DESCRIPTION `Imports:`\n  - \"My package needs this package to work\"\n- NAMESPACE `@import`\n  - \"When my package uses this function, use the one from the package in the NAMESPACE\"\n\n- Additional effects:\n  - NAMESPACE removes need for `::`\n      - `package::function()` or `function()`\n\n::: {.notes}\nWhen you import a function in DESCRIPTION you are saying that \"My package needs this package to work\", when you import a function in NAMESPACE you are saying \"When my package uses this function, use the one from the package in the NAMESPACE\" even if there exist functions with the same name.\nAn added benefit is that if you just import a package in DESCRIPTION you need to specify in your code which package it is from as it is not attached but if you import it from NAMESPACE this need is removed.\nFinally: Realise that writing package::function() removes the need to import functions to NAMESPACE and is best, but it takes a while to write of course.\n:::\n\n## data/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n**Package types:**\n\n- Functional\n  - Performs a or several functions\n  - Contains no or small datasets, <1 MB\n- Dataset\n  - Contains an interesting dataset\n  - Easy to import\n  - Few or no functions\n\n::: {.notes}\nIncluding data is good if there is some information intrinsic to some of your functions or to provide examples of usage. In some packages it can be the main reason for the package, for example a R package carrying some census data which is easy for people to load. Unless your package is such a data package you should strive to keep it less than 1 MB.\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n**Data types:**\n\n- Binary data, `.Rdata` or `.rda`\n    - `data/` folder\n    - A single object with the same name as the data file\n- Function data\n    - `R/sysdata.rda`\n    - Data that your functions need\n- Raw data, `.xlsx`,`.csv` etc\n    - `inst/extdata`folder\n\n::: {.notes}\nYou can have three types of data in R, binary data is an R object saved to data/ directory with the same name as the object. These can be slightly larger files.\nData that your functions need, for example in life sciences you might save the positions of the centromeres within a package that plots the genome, or for a plotting program you may want to save a list of colors, this is usually saved in R/sysdata.rda. The objects saved there will be available to your functions by name within the package.\nIf you want to include raw data, usually you should try not to or convert it to binary data, you can save those in inst/extdata.\n:::\n\n:::\n::::\n\n```\n# Create data in package automatically\nusethis::use_data(object, package)\n\n# Manually\nsave(object, file=\"path/to/package/data/object.Rdata\")\n\n# Access raw data\nsystem.file(\"extdata\",\"filename.csv\", package=\"packagename\")\n```\n\n::: {.notes}\nHere we see some code where we use usethis to save a object directly to data/ directory with the correct name. This is the same thing basically as using the save command and pointing to the correct location, with correct filename. If you want to access data belongning to a package you can use the system.file command in R.\n:::\n\n## tests/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n* What to test?\n + That the return value is what is expected given a certain input\n \n* Why test?\n + Improved development stability\n + Working in group/open source\n + Working on big package\n \n![](assets/test.jpeg){width=\"70%\"}\n\n::: {.notes}\nTests or unit tests formally checks that we get the correct result from a function given a specific input. This can be good when working on big and/or complex packages or together with other people as it directly tells you if a change has been made that has changed the expected behaviour of the package.\n:::\n\n:::\n::: {.column width=\"50%\"}\n\n- How to test?\n - Uses `testthat` package for testing and `usethis` package for setup <br>\n - Initialize with `use_testthat()`\n - Create test for a function with `use_test(\"call_me\")`\n - Testfile: `tests/testthat/test-call_me.R`\n - Run test with `devtools::test()` or `check()`\n\n[*tests/testthat/test-call_me.R:*]{.small}\n\n```\ntest_that(\"multiplication works\", {\n  expect_equal(2 * 2, 4)\n})\n```\n:::\n\n::: {.notes}\nThis is the standard template created when use_test() is called.\n:::\n\n::::\n\n## src/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n- Compiled code\n  - `Rcpp`\n  - `rJava`\n- Scripts\n  - `inst/`\n  - Dependencies\n\n:::\n\n::: {.notes}\nI wont go deeply into this, but I want it to be something you are aware of.\nR isnt the fastest language, so sometimes you may want to put for example C or C++ in your package for certain functions. There are two ways to go about this.\nEither you can integrate, using packages such as Rcpp, or rJava and others, or you just straight up put code such as .py files in inst/python. This should be avoided as it creates additional dependencies on the user. So lets look at an example of how to set up your package to use Rcpp, which is probably the easiest and most common.\n:::\n\n::: {.column width=\"50%\"}\n\n1. `usethis::use_rcpp()`\n    + Edit DESCRIPTION\n    + `#' @useDynLib packagename`\n    + `#' @importFrom Rcpp sourceCpp`\n2. `.cpp` file in `src/`\n\n:::\n::::\n\n[*src/filename.cpp:*]{.small}\n\n```\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// This is a simple example of exporting a C++ function to R. You can\n// source this function into an R session using the Rcpp::sourceCpp\n// function (or via the Source button on the editor toolbar). Learn\n// more about Rcpp at:\n//\n//   http://www.rcpp.org/\n//   http://adv-r.had.co.nz/Rcpp.html\n//   http://gallery.rcpp.org/\n//\n\n// [[Rcpp::export]]\nNumericVector timesTwo(NumericVector x) {\n  return x * 2;\n}\n\n```\n\n::: {.notes}\nFirst you can call usethis::use_rcpp() which automates the processes of adding information to your DESCRIPTION and telling you to add two tags for documentation somewhere in your packages code. Then we create a c++ file, from Rstudio preferable, in our src/ folder. It will look as shown here by default. The only important parts are the header and the rcpp::export located above the example function.\n:::\n\n## src/\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n\n* Compiled code\n  + `Rcpp`\n  + `rJava`\n* Scripts\n  + `inst/`\n  + Dependencies\n:::\n\n::: {.column width=\"50%\"}\n\n1. `usethis::use_rcpp()`\n    + Edit DESCRIPTION\n    + `#' @useDynLib packagename`\n    + `#' @importFrom Rcpp sourceCpp`\n2. `.cpp` file in `src/`\n3. `pkgbuild::compile_dll()`\n4. `devtools::document()`\n5. `Build & Reload`\n6. Add documentation to `.cpp`\n\n:::\n::::\n\n[*R/RcppExports.R:*]{.small}\n\n```\n# Generated by using Rcpp::compileAttributes() -> do not edit by hand\n# Generator token: 10BE3573-1514-4C36-9D1C-5A225CD40393\n\ntimesTwo <- function(x) {\n    .Call('_typicalr_timesTwo', PACKAGE = 'typicalr', x)\n}\n```\n\n::: {.notes}\nTo get this to R code we first build the documentation, which exports the function, and your tags for using rcpp, to NAMESPACE, and then Build & Reload in Rstudio, I am sure there are ways to do this with devtools as well. At this stage the cpp function is callable in R, through the RcppExports.R file that has been created in R/ directory, which looks like this. Just like with our normal functions we can add roxygen documentation for this in the cpp file.\n:::\n\n## CRAN and `R CMD check`\n\n:::: {.columns}\n::: {.column width=\"60%\"}\n\n* **C**omprehensive **R** **A**rchive **N**etwork\n  + R package repository\n  + Sign of quality\n* `R CMD check`\n  + More than 50 individual checks\n  + Three messages:\n      + **ERROR**: Always fix.\n      + **WARNING**: Should probably fix. Definitely for CRAN submit.\n      + **NOTE**: Try to solve to CRAN submit, else do not bother.\n  + `devtools::check()`\n\n:::\n\n::: {.column width=\"40%\"}\n![](assets/Rlogo.svg){width=\"80%\"}\n:::\n::::\n\n::: {.notes}\nR CMD check is a command that checks your package for common problems. From filenames and permissions to information in DESCRIPTION and NAMESPACE and wether you can install it. Note that this can only check if it is installable in your current environment, not on other operating systems. It also checks that your package is compatible with CRAN, such as not having the same name as a package that already exists there and that the required information in DESCRIPTION is present. It also checks your actual code, making sure that there are no problems or dependencies that are not met.\nThere are three types of messages that R CMD CHECK can complain about. Errors are always bad, and you should fix them no matter what. Warnings are pretty bad, but there may be some false positives. You should try to fix them especially if you are submitting the package to cran. Notes you can take or leave, but if you are a completionist you should aspire to fix even these.\nAs with most other commands, devtools has a function for this called check() which performs r cmd check and some additional operations such as automatically updating the documentation and bundling the package before checking.\n:::\n\n<!-- -- -->\n\n<!-- .pull-right-40[ -->\n<!-- <br> -->\n<!-- <img src=\"assets/TravisCI.png\", style=\"width:80%\"> -->\n<!-- ] -->\n\n<!-- .pull-left-60[ -->\n<!-- * Travis-CI -->\n<!--   + Integrated with your github repository -->\n<!--   + Automates `R CMD check` -->\n<!--   + Multiple operating systems -->\n<!-- ] -->\n\n<!-- ??? -->\n<!-- If you are developing your package on github you can set up Travis to run this check every time you commit your package. One of the best things is that it tests it for multiple different operating systems. -->\n\n## Rstudio and Github\n\n:::: {.columns}\n::: {.column width=\"60%\"}\n\n- `git`\n  - Version control\n  - Working in groups\n  - Rstudio integration\n- Github\n  - Unoffical repository\n  - `devtools::install_github()`\n  - R Package development environment\n  - Issues\n\n:::\n\n::: {.column width=\"40%\"}\n![](assets/github.png)\n:::\n::::\n\n::: {.notes}\nThat was all I was going to say about the different pieces of a package. There are more but I think those are the main parts and you can dive into the others if you are making an advanced package.\nNow let's talk alittle about hosting your package. Using version control, such as git, is a good way to work on your package, especially if you are working on it in a group. This is because it keeps track of changes and conflicts so that if multiple people are working on the same file no bugs appear. You can also setup Rstudio to work with git and github. A package hosted on github can be directly installed using devtools::install_github() and what you see more and more nowadays is that a stable release is on CRAN whereas development versions are on github. It is also a great place for others to contribute to your code and to report issues they have with your package.\n:::\n\n## Github Actions\n\n* What it can do\n  + Integrated with your github repository\n  + Automates `R CMD check`\n  + Test on multiple operating systems\n\n* How it works\n  + Add a file with instructions to `.github/workflows/workflow-name.yaml`\n  + Triggered by action, for example `push`\n  + Most common R related workflows available in [github r-libs repository](https://github.com/r-lib/actions)\n\n![](assets/github_actions.png){width=\"80%\"}\n\n::: {.notes}\nLets talk a bit more about setting up github actions. There is an extra assignment in the lab where you set this up for your R package. To get it working you need to have enabled the permissions for your github account to use workflow scopes. Once you have that you create a yaml file of instructions in a directory where github knows to look for such things. Then when you push this to github and your repository updates, it will additionally run whichever tests you have specified.\n:::\n\n## Summary\n\n:::: {.columns}\n::: {.column width=\"70%\"}\n\n- What is an R package?\n- Possible package states\n<!-- - Repositories Include? -->\n- Package structure:\n    - Code | `r/`\n    - Metadata | `DESCRIPTION`\n    - Documentation | `man/`\n    - Vignettes\n    - Import & Export | `NAMESPACE`\n    - Data | `data/`\n    - Tests | `tests/`\n    - Compiled code | `src/`\n<!-- - Installed files | `inst/ Include? -->     \n<!-- - Testing  Include? -->\n- CRAN and `R CMD check`\n- Rstudio and Github\n<!-- - Package website | `pkgdown`  Include? -->\n:::\n\n::: {.column width=\"30%\"}  \n[![](assets/rpkg_book.png)\n[http://r-pkgs.had.co.nz/]{.smaller}](http://r-pkgs.had.co.nz/)\n:::\n::::\n\n## {background-image=\"../../assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n         _                     \nplatform x86_64-conda-linux-gnu\nos       linux-gnu             \nmajor    4                     \nminor    2.2                   \n```\n:::\n:::\n\n\n[2023 • [SciLifeLab](https://www.scilifelab.se/) • [NBIS](https://nbis.se/) • [RaukR](https://nbisweden.github.io/workshop-RaukR-2306/)]{.smaller}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}