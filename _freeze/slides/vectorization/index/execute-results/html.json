{
  "hash": "c9675261b4fbee4f90010dd1aeac3ad4",
  "result": {
    "markdown": "---\ntitle: \"Vectorization in R\"\nauthor: \"Marcin Kierczak\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n## {visibility=\"hidden\"}\n\n\n::: {.cell}\n\n:::\n\n\n## Learning Outcomes\n\nBy the end of this module, you will:\n\n- understand how to write more efficient loops\n- be able to vectorize most loops\n- understand how the `apply*` functions work\n- be aware of the `purrr` package\n- understand what a recursive call is\n\n## The simplest of all `for` loops\n\nSay, we want to add 1 to every element of a vector:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:5)\nvec\nfor (i in vec) {\n  vec[i] <- vec[i] + 1\n}\nvec\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 1 2 3 4 5\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n\n. . .\n\nExactly the same can be achieved in R by means of **vectorization**:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvec <- c(1:5)\nvec + 1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2 3 4 5 6\n```\n:::\n:::\n\n\nWhich is better than? ðŸ˜•\n\n## Repeating actions &mdash; vectorization\n\nLet us compare the time of execution of the vectorized version (vector with 10,000 elements):\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.005   0.000   0.005 \n```\n:::\n:::\n\n\n. . .\n\nto the loop version:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.048   0.004   0.053 \n```\n:::\n:::\n\n\n## Vectorization &mdash; the problem\n\n\n::: {.cell}\n\n```{.r .cell-code}\nis_a_droid <- function(x) {\n  droids <- c('2-1B', '4-LOM', '8D8', '0-0-0', 'AP-5', 'AZI-3', 'Mister Bones', 'BB-8', 'BB-9E', 'BD-1', 'BT-1', 'C1-10P', 'C-3PO', 'R2-D2')\n  if (x %in% droids) {\n    return(T)\n  } else {\n    return(F)\n  }\n}\n\ntest <- c('Anakin', 'Vader', 'R2-D2', 'AZI-3', 'Luke')\nis_a_droid(test)\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in if (x %in% droids) {: the condition has length > 1\n```\n:::\n:::\n\n\n## Vectorization &mdash; the solution(s)\n\nThe `base::Vectorize` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvectorized_is_a_droid <- base::Vectorize(is_a_droid, vectorize.args = c('x'))\nvectorized_is_a_droid(test)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \n```\n:::\n:::\n\n\n. . .\n\nThe `apply*` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\napply(as.matrix(test), FUN = is_a_droid, MARGIN = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlapply(test, FUN=is_a_droid) %>% unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsapply(test, is_a_droid)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \n```\n:::\n:::\n\n\n## Vectorization &mdash; the solution(s)\n\nThe `vapply`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = TRUE)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n FALSE  FALSE   TRUE   TRUE  FALSE \n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = 1)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\nAnakin  Vader  R2-D2  AZI-3   Luke \n     0      0      1      1      0 \n```\n:::\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = c(1,0))\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in vapply(test, is_a_droid, FUN.VALUE = c(1, 0)): values must be length 2,\n but FUN(X[[1]]) result is length 1\n```\n:::\n\n```{.r .cell-code}\nvapply(test, is_a_droid, FUN.VALUE = 'a')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in vapply(test, is_a_droid, FUN.VALUE = \"a\"): values must be type 'character',\n but FUN(X[[1]]) result is type 'logical'\n```\n:::\n:::\n\n\n. . .\n\nOr the `purrr` way:\n\n\n::: {.cell}\n\n```{.r .cell-code}\npurrr::map(test, is_a_droid) %>% unlist()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] FALSE FALSE  TRUE  TRUE FALSE\n```\n:::\n:::\n\n\n## Recursion\n\nWhen we explicitly repeat an action using a loop, we talk about **iteration**. We can also repeat actions by means of **recursion**, i.e. when a function calls itself. Let us implement a factorial $!$:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial.rec <- function(x) {\n  if (x == 0 || x == 1)\n    return(1)\n  else\n    return(x * factorial.rec(x - 1)) # Recursive call!\n}\nfactorial.rec(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 120\n```\n:::\n:::\n\n\n## Recursion = iteration?\n\nYes, every iteration can be converted to recursion (Church-Turing conjecture) and *vice versa*. It is not always obvious, but theoretically it is doable. Let's see how to implement *factorial* in iterative manner:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfactorial.iter <- function(x) {\n  if (x == 0 || x == 1)\n    return(1)\n  else {\n    tmp <- 1\n    for (i in 2:x) {\n      tmp <- tmp * i\n    }\n    return(tmp)  \n  }\n}\nfactorial.iter(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 120\n```\n:::\n:::\n\n\n## Recursion == iteration, really?\n\nMore writing for the iterative version, right? What about the time efficiency?  \nThe recursive version:\n\n\n::: {.cell}\n\n:::\n\n\nAnd the iterative one:\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n         Function_Call Elapsed_Time_sec Total_RAM_Used_MiB Peak_RAM_Used_MiB\n1 factorial.iter(2000)            0.003                  0               0.1\n```\n:::\n:::\n\n\n## Loops &mdash; avoid growing data\n\nAvoid changing dimensions of an object inside the loop:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- c() # Initialize\nfor (i in 1:100) {\n  v <- c(v, i)\n}\n```\n:::\n\n\n. . .\n\nIt is much better to do it like this:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nv <- rep(NA, 100) # Initialize with length\nfor (i in 1:100) {\n  v[i] <- i\n}\n```\n:::\n\n\n## {background-image=\"../../assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n         _                     \nplatform x86_64-conda-linux-gnu\nos       linux-gnu             \nmajor    4                     \nminor    2.2                   \n```\n:::\n:::\n\n\n[2023 â€¢ [SciLifeLab](https://www.scilifelab.se/) â€¢ [NBIS](https://nbis.se/) â€¢ [RaukR](https://nbisweden.github.io/workshop-RaukR-2306/)]{.smaller}\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}