{
  "hash": "739a172d09cf1ff177ce690d6c5cce3c",
  "result": {
    "markdown": "---\ntitle: \"Debugging, Profiling, and Optimization\"\nauthor: \"Marcin Kierczak\"\nimage: \"assets/featured.jpg\"\nformat: revealjs\n---\n\n\n## {visibility=\"hidden\"}\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(tictoc)\nlibrary(DT)\nlibrary(profvis)\nlibrary(Rgraphviz)\nlibrary(proftools)\nlibrary(profr)\nlibrary(pryr)\nlibrary(microbenchmark)\nlibrary(ggplot2)\n# remotes::install_github(\"cdeterman/gpuR\")\n#library(gpuR)\n```\n:::\n\n\n## Topics of This Presentation\n\n<br><br>\n\nCode:\n<br>\n\n- **Debugging** -- my code does not run.\n- **Profiling** -- now it does run but... out of memory!\n- **Optimization** -- making things better.\n\n## Types of bugs\n\n### There are different types of bugs we can introduce:\n\n- Syntax -- `prin(var1), mean(sum(seq((x + 2) * (y - 9 * b)))`\n- Arithmetic -- `x/0` (not in R, though!) `Inf/Inf`\n- Type -- `mean('a')`\n- Logic -- everything works and produces seemingly valid output that is WRONG!\n\n### To avoid bugs:\n\n- Encapsulate your code in smaller units (functions), you can test.\n- Use classes and type checking.\n- Test at the boundaries, e.g. loops at min and max value.\n- Feed your functions with test data that should result with a known output.\n- Use *antibugging*: `stopifnot(y <= 75)`\n\n## Arithmetic bugs\n\n\n::: {.cell}\n\n```{.r .cell-code}\n(vec <- seq(0.1, 0.9, by=0.1))\nvec == 0.7 \nvec == 0.5\n(0.5 + 0.1) - 0.6\n(0.7 + 0.1) - 0.8 # round((0.7 + 0.1) , digits = 2) - 0.8\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.1 0.2 0.3 0.4 0.5 0.6 0.7 0.8 0.9\n[1] FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE FALSE\n[1] FALSE FALSE FALSE FALSE  TRUE FALSE FALSE FALSE FALSE\n[1] 0\n[1] -1.110223e-16\n```\n:::\n:::\n\n\nBeware of floating point arithmetic!\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhead(unlist(.Machine))\nhead(unlist(.Platform))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n    double.eps double.neg.eps    double.xmin    double.xmax    double.base \n  2.220446e-16   1.110223e-16  2.225074e-308  1.797693e+308   2.000000e+00 \n double.digits \n  5.300000e+01 \n   OS.type   file.sep dynlib.ext        GUI     endian    pkgType \n    \"unix\"        \"/\"      \".so\"      \"X11\"   \"little\"   \"source\" \n```\n:::\n:::\n\n\n## Handling Errors\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninput <- c(1, 10, -7, -2/5, 0, 'char', 100, pi)\nfor (val in input) {\n  (paste0('Log of ', val, 'is ', log10(val)))\n}\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log10(val): non-numeric argument to mathematical function\n```\n:::\n:::\n\n\nOne option is to use the `try` block:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (val in input) {\n  val <- as.numeric(val)\n  try(print(paste0('Log of ', val, ' is ', log10(val))))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Log of 1 is 0\"\n[1] \"Log of 10 is 1\"\n[1] \"Log of -7 is NaN\"\n[1] \"Log of -0.4 is NaN\"\n[1] \"Log of 0 is -Inf\"\n[1] \"Log of NA is NA\"\n[1] \"Log of 100 is 2\"\n[1] \"Log of 3.14159265358979 is 0.497149872694133\"\n```\n:::\n:::\n\n\n## Handling Errors with `tryCatch`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfor (val in input) {\n  val <- as.numeric(val)\n  result <- tryCatch(log10(val), \n              warning = function(w) { print('Negative argument supplied. Negating.'); log10(-val) }, \n              error = function(e) { print('Not a number!'); NaN })\n  print(paste0('Log of ', val, ' is ', result))\n}\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"Log of 1 is 0\"\n[1] \"Log of 10 is 1\"\n[1] \"Negative argument supplied. Negating.\"\n[1] \"Log of -7 is 0.845098040014257\"\n[1] \"Negative argument supplied. Negating.\"\n[1] \"Log of -0.4 is -0.397940008672038\"\n[1] \"Log of 0 is -Inf\"\n[1] \"Log of NA is NA\"\n[1] \"Log of 100 is 2\"\n[1] \"Log of 3.14159265358979 is 0.497149872694133\"\n```\n:::\n:::\n\n\n## Debugging -- Errors and Warnings\n\n- An error in your code will result in a call to the `stop()` function that:\n  - Breaks the execution of the program (loop, if-statement, etc.)\n  - Performs the action defined by the global parameter `error`.\n- A warning just prints out the warning message (or reports it in another way)\n- Global parameter `error` defines what R should do when an error occurs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(error = )\n```\n:::\n\n\n- You can use `simpleError()` and `simpleWarning()` to generate errors and warnings in your code:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  if (x < 0) {\n    x <- abs(x)\n    w <- simpleWarning(\"Value less than 0. Taking abs(x)\")\n    w\n  }\n}\n```\n:::\n\n\n## Debugging -- What are my Options?\n\n- Old-school debugging: a lot of `print` statements\n  - print values of your variables at some checkpoints,\n  - sometimes fine but often laborious,\n  - need to remove/comment out manually after debugging.\n- Dumping frames\n  - on error, R state will be saved to a file,\n  - file can be read into debugger,\n  - values of all variables can be checked,\n  - can debug on another machine, e.g. send dump to your colleague!\n- Traceback\n  - a list of the recent function calls with values of their parameters,\n- Step-by-step debugging\n  - execute code line by line within the debugger\n\n## Option 1: Dumping Frames\n\n\n::: {.cell}\n\n```{.r .cell-code}\noptions(error = quote(dump.frames(\"testdump\", TRUE)))\n\nf <- function(x) {\n    sin(x)\n}\nf('test')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in sin(x): non-numeric argument to mathematical function\n```\n:::\n\n```{.r .cell-code}\noptions(error = NULL)\nload(\"testdump.rda\")\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in readChar(con, 5L, useBytes = TRUE): cannot open the connection\n```\n:::\n\n```{.r .cell-code}\n# debugger(testdump)\n```\n:::\n\n\n```\nMessage:  Error in sin(x) : non-numeric argument to mathematical function <br>\nAvailable environments had calls: <br>\n1: f(\"test\") <br>\n <br>\nEnter an environment number, or 0 to exit   <br>\nSelection: 1 <br>\nBrowsing in the environment with call: <br>\n   f(\"test\") <br>\nCalled from: debugger.look(ind) <br>\nBrowse[1]> x <br>\n[1] \"test\" <br>\nBrowse[1]>  <br>\n[1] \"test\" <br>\nBrowse[1]> \n```\n\nLast empty line brings you back to the environments menu.\n\n## Option 2: Traceback\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf <- function(x) {\n  log10(x)  \n}\n\ng <- function(x) {\n  f(x)\n}\ng('test')\n```\n\n::: {.cell-output .cell-output-error}\n```\nError in log10(x): non-numeric argument to mathematical function\n```\n:::\n:::\n\n\n```\n> traceback()<br>\n2: f(x) at #2<br>\n1: g(\"test\")<br>\n```\n\n`traceback()` shows what were the function calls and what parameters were passed to them when the error occurred.\n\n## Option 3: Debug step-by-step\n\nLet us define a new function `h(x, y)`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh <- function(x, y) { \n  f(x) \n  f(y) \n  }\n```\n:::\n\n\nNow, we can use `debug()` to debug the function in a step-by-step manner:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndebug(h)\nh('text', 7)\nundebug(h)\n```\n:::\n\n\n## Option 3: Debug step-by-step cted.\n\n`n` -- execute next line, `c` -- execute whole function, `q` -- quit debugger mode.\n\n```\n> debug(h)<br>\n> h('text', 7)<br>\ndebugging in: h(\"text\", 7)<br>\ndebug at #1: {<br>\n    f(x)<br>\n    f(y)<br>\n}<br>\n</tt>\n--\n<tt>Browse[2]> x<br>\n[1] \"text\"<br></tt>\n--\n<tt>Browse[2]> y<br>\n[1] 7<br></tt>\n--\n<tt>Browse[2]> n<br>\ndebug at #2: f(x)<br></tt>\n--\n<tt>Browse[2]> x<br>\n[1] \"text\"<br></tt>\n--\n<tt>Browse[2]> n<br>\nError in log10(x) : non-numeric argument to mathematical function<br>\n```\n\n## Profiling -- `proc.time()`\n\nProfiling is the process of identifying memory and time bottlenecks in your code.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nproc.time()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  1.972   0.626   1.627 \n```\n:::\n:::\n\n\n- `user time` -- CPU time charged for the execution of user instructions of the calling process,\n- `system time` -- CPU time charged for execution by the system on behalf of the calling process,\n- `elapsed time` -- total CPU time elapsed for the currently running R process.\n\n\n::: {.cell}\n\n```{.r .cell-code}\npt1 <- proc.time()\ntmp <- runif(n =  10e5)\npt2 <- proc.time()\npt2 - pt1\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.031   0.000   0.031 \n```\n:::\n:::\n\n\n## Profiling -- `system.time()`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsystem.time(runif(n = 10e6))\nsystem.time(rnorm(n = 10e6))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  0.351   0.007   0.359 \n   user  system elapsed \n  0.634   0.003   0.637 \n```\n:::\n:::\n\n\nAn alternative approach is to use `tic` and `toc` statements from the `tictoc` package.\n\n\n::: {.cell hash='index_cache/revealjs/tictoc_10f436cc9863b57c7e540339606b0f32'}\n\n```{.r .cell-code}\nlibrary(tictoc)\ntic()\ntmp1 <-runif(n = 10e6)\ntoc()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n0.268 sec elapsed\n```\n:::\n:::\n\n\n## Profiling in Action\n\nLet's see profiling in action! We will define four functions that fill a large vector in two different ways:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_fill_loop1 <- function(n = 10e6, f) {\n  result <- NULL\n  for (i in 1:n) {\n    result <- c(result, eval(call(f, 1)))\n  }\n  return(result)\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_fill_loop2 <- function(n = 10e6, f) {\n  result <- vector(length = n)\n  for (i in 1:n) {\n    result[i] <- eval(call(f, 1))\n  }\n  return(result)\n}\n```\n:::\n\n\n## Profiling in Action cted.\n\nIt is maybe better to use...\n\n. . .\n\nvectorization!\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_fill_vec1 <- function(n = 10e6, f) {\n  result <- NULL\n  result <- eval(call(f, n))\n  return(result)\n}\n```\n:::\n\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nfun_fill_vec2 <- function(n = 10e6, f) {\n  result <- vector(length = n)\n  result <- eval(call(f, n))\n  return(result)\n}\n```\n:::\n\n\n## Profiling our functions\n\n\n::: {.cell hash='index_cache/revealjs/profile_loop_efde299692f281dd5e6e528ebd451524'}\n\n```{.r .cell-code}\nsystem.time(fun_fill_loop1(n = 10e4, \"runif\")) # Loop 1\nsystem.time(fun_fill_loop2(n = 10e4, \"runif\")) # Loop 2\nsystem.time(fun_fill_vec1(n = 10e4, \"runif\"))  # Vectorized 1\nsystem.time(fun_fill_vec2(n = 10e4, \"runif\"))  # Vectorized 2\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n   user  system elapsed \n  7.854   0.168   8.022 \n   user  system elapsed \n  0.494   0.016   0.510 \n   user  system elapsed \n  0.003   0.000   0.002 \n   user  system elapsed \n  0.002   0.000   0.002 \n```\n:::\n:::\n\n\nThe `system.time()` function is not the most accurate though. During the lab, we will experiment with package `microbenchmark`.\n\n## More advanced profiling\n\nWe can also do a bit more advanced profiling, including the memory profiling, using, e.g. `Rprof()` function.\n\n\n\n\n\nAnd let us summarise:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsummary <- summaryRprof('profiler_test.out', memory='both')\nDT::datatable(summary$by.self, options=list(pageLength = 10, searching = F, info = F))\n#knitr::kable(summary$by.self)\n```\n\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-a551c0305c265e6aec69\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-a551c0305c265e6aec69\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"\\\"print.default\\\"\",\"\\\"eval\\\"\",\"\\\"runif\\\"\",\"\\\"fun_fill_loop2\\\"\",\"\\\"parent.frame\\\"\",\"\\\"is.list\\\"\",\"\\\"is.pairlist\\\"\",\"\\\"baseenv\\\"\",\"\\\"close.connection\\\"\",\"\\\"findCenvVar\\\"\"],[2.84,0.82,0.63,0.24,0.08,0.04,0.04,0.03,0.01,0.01],[59.92,17.3,13.29,5.06,1.69,0.84,0.84,0.63,0.21,0.21],[2.84,1.64,0.63,1.89,0.08,0.04,0.04,0.03,0.01,0.01],[59.92,34.6,13.29,39.87,1.69,0.84,0.84,0.63,0.21,0.21],[[2.8],[703.2],[275.9],[872.6],[48.5],[10.5],[0],[6.4],[0],[1.5]]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>self.time<\\/th>\\n      <th>self.pct<\\/th>\\n      <th>total.time<\\/th>\\n      <th>total.pct<\\/th>\\n      <th>mem.total<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"pageLength\":10,\"searching\":false,\"info\":false,\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,3,4,5]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Profiling -- `profr` package\n\nThere are also packages available that enable even more advanced profiling:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profr)\nRprof(\"profiler_test2.out\", interval = 0.01)\ntmp <- table(sort(rnorm(1e5)))\nRprof(NULL)\nprofile_df <- parse_rprof('profiler_test2.out')\n```\n:::\n\n\nThis returns a table that can be visualised:\n\n\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"datatables html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-03641597ae73ef04bba0\" style=\"width:100%;height:auto;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-03641597ae73ef04bba0\">{\"x\":{\"filter\":\"none\",\"vertical\":false,\"data\":[[\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\",\"10\",\"11\",\"12\",\"13\",\"14\",\"15\",\"16\",\"17\",\"18\",\"19\",\"20\",\"21\",\"22\",\"23\",\"24\",\"25\",\"26\",\"27\",\"28\",\"29\",\"30\",\"31\",\"32\",\"33\",\"34\",\"35\",\"36\",\"37\",\"38\",\"39\",\"40\",\"41\",\"42\",\"43\",\"44\",\"45\",\"46\",\"47\"],[1,1,2,2,2,3,3,3,3,4,4,4,5,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38],[1,2,1,2,3,1,2,3,4,1,2,3,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[1,1,1,1,1,1,1,1,2,1,1,2,1,2,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[\"table\",\"cb\",\"sort\",\"factor\",\"tryCatch\",\"rnorm\",\"sort.default\",\"unique\",\"tryCatchList\",\"sort.int\",\"unique.default\",\"tryCatchOne\",\"order\",\"doTryCatch\",\"inspect_env\",\"lapply\",\"FUN\",\"scalar\",\"trimws\",\"mysub\",\"sub\",\"is.factor\",\"mysub\",\"sub\",\"is.factor\",\"try_capture_str\",\"tryCatch\",\"tryCatchList\",\"tryCatchOne\",\"doTryCatch\",\"capture_str\",\"paste0\",\"utils::capture.output\",\"withVisible\",\"...elt\",\"utils::str\",\"str.default\",\"cat\",\"formObj\",\"maybe_truncate\",\"nchar.w\",\"paste\",\"format.fun\",\"format\",\"format.default\",\"prettyNum\",\"is.na\"],[0,0.46,0,0.04,0.46,0,0.02,0.04,0.46,0.02,0.04,0.46,0.02,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46,0.46],[0.46,0.48,0.04,0.46,0.48,0.02,0.04,0.28,0.48,0.04,0.28,0.48,0.04,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48,0.48],[1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[false,false,false,false,false,true,false,false,false,false,true,false,true,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,false,true],[0.46,0.02,0.04,0.42,0.02,0.02,0.02,0.24,0.02,0.02,0.24,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02,0.02],[\"base\",null,\"base\",\"base\",\"base\",\"stats\",\"base\",\"base\",null,\"base\",\"base\",null,\"base\",null,null,\"base\",null,null,\"base\",null,\"base\",\"base\",null,\"base\",\"base\",null,\"base\",null,null,null,null,\"base\",null,\"base\",null,null,null,\"base\",null,null,null,\"base\",null,\"base\",\"base\",\"base\",\"base\"]],\"container\":\"<table class=\\\"display\\\">\\n  <thead>\\n    <tr>\\n      <th> <\\/th>\\n      <th>level<\\/th>\\n      <th>g_id<\\/th>\\n      <th>t_id<\\/th>\\n      <th>f<\\/th>\\n      <th>start<\\/th>\\n      <th>end<\\/th>\\n      <th>n<\\/th>\\n      <th>leaf<\\/th>\\n      <th>time<\\/th>\\n      <th>source<\\/th>\\n    <\\/tr>\\n  <\\/thead>\\n<\\/table>\",\"options\":{\"pageLength\":5,\"searching\":false,\"info\":false,\"columnDefs\":[{\"className\":\"dt-right\",\"targets\":[1,2,3,5,6,7,9]},{\"orderable\":false,\"targets\":0}],\"order\":[],\"autoWidth\":false,\"orderClasses\":false,\"lengthMenu\":[5,10,25,50,100]}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n# Profiling -- `profr` package cted.\n\nWe can also plot the results using -- `proftools` package-\n\n\n::: {.cell layout-align=\"center\"}\n\n```{.r .cell-code}\nlibrary(Rgraphviz)\nlibrary(proftools) # depends on \"graph\" and \"Rgraphviz\" packages\nprofile_df2 <- readProfileData(\"profiler_test2.out\")\nplotProfileCallGraph(profile_df2, style = google.style, score = \"total\")\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/show_profr_result_plot-1.png){fig-align='center' width=384}\n:::\n:::\n\n\n## Profiling with `profvis`\n\nYet another nice way to profile your code is by using Hadley Wickham's `profvis` package:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(profvis)\nprofvis({fun_fill_loop2(1e4, 'runif')\n  fun_fill_vec2(1e4, 'runif')\n})\n```\n:::\n\n\n## Profiling with `profvis` cted.\n\n\n::: {.cell}\n::: {.cell-output-display}\n```{=html}\n<div class=\"profvis html-widget html-fill-item-overflow-hidden html-fill-item\" id=\"htmlwidget-30f42c6c4fc9e2b2357b\" style=\"width:100%;height:600px;\"></div>\n<script type=\"application/json\" data-for=\"htmlwidget-30f42c6c4fc9e2b2357b\">{\"x\":{\"message\":{\"prof\":{\"time\":[1,1,1,2,2,2,3,3,3,4,4,4,5,5,5],\"depth\":[3,2,1,3,2,1,3,2,1,3,2,1,3,2,1],\"label\":[\"eval\",\"fun_fill_loop2\",\".main\",\"runif\",\"fun_fill_loop2\",\".main\",\"eval\",\"fun_fill_loop2\",\".main\",\"eval\",\"fun_fill_loop2\",\".main\",\"eval\",\"fun_fill_loop2\",\".main\"],\"filenum\":[null,2,null,null,2,null,null,2,null,null,2,null,null,2,null],\"linenum\":[null,2,null,null,2,null,null,2,null,null,2,null,null,2,null],\"memalloc\":[30.2715606689453,30.2715606689453,30.2715606689453,34.0936126708984,34.0936126708984,34.0936126708984,39.6345901489258,39.6345901489258,39.6345901489258,43.2494735717773,43.2494735717773,43.2494735717773,48.1593627929688,48.1593627929688,48.1593627929688],\"meminc\":[0,0,0,3.82205200195312,0,0,5.54097747802734,0,0,3.61488342285156,0,0,4.90988922119141,0,0],\"filename\":[null,\"<expr>\",null,null,\"<expr>\",null,null,\"<expr>\",null,null,\"<expr>\",null,null,\"<expr>\",null]},\"interval\":10,\"files\":[{\"filename\":\"<expr>\",\"content\":\"library(profvis)\\nprofvis({fun_fill_loop2(1e4, 'runif')\\n  c()\\n})\",\"normpath\":\"<expr>\"}],\"prof_output\":\"/tmp/RtmpAYjOcP/file2619d1da53a00.prof\",\"highlight\":{\"output\":[\"^output\\\\$\"],\"gc\":[\"^<GC>$\"],\"stacktrace\":[\"^\\\\.\\\\.stacktraceo(n|ff)\\\\.\\\\.$\"]},\"split\":\"h\"}},\"evals\":[],\"jsHooks\":[]}</script>\n```\n:::\n:::\n\n\n## Optimizing your code\n\n::: {.blockquote}\nWe should forget about small efficiencies, say about 97% of the time: premature optimization is the root of all evil. Yet we should not pass up our opportunities in that critical 3%. A good programmer will not be deluded into complacency by such reasoning, he will be wise to look carefully at the critical code; but only after that code has been identified.\n\n-- Donald Knuth\n:::\n\n:::: {.columns}\n::: {.column width=\"50%\"}\n![](assets/xkcd_automation.png){height=\"300px\"}  \n[source: http://www.xkcd/com/1319]{.smaller}\n:::\n\n::: {.column width=\"50%\"}\n![](assets/xkcd_is_it_worth_the_time_2x.png){height=\"300px\"}  \n[source: http://www.xkcd/com/1205]{.smaller}\n:::\n::::\n\n## Ways to optimize the code\n\n- write it in a more efficient way, e.g. use vectorization or `*apply` family instead of loops etc.,\n- allocating memory to avoid copy-on-modify,\n- use package `BLAS` for linear algebra,\n- use `bigmemory` package,\n- GPU computations,\n- multicore support, e.g. `multicore`, `snow`\n- use `data.table` or `tibble` instead of `data.frame`\n\n## Copy-on-modify\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(pryr)\norder <- 1024\nmatrix_A <- matrix(rnorm(order^2), nrow = order)\nmatrix_B <- matrix_A\n```\n:::\n\n\n. . .\n\nCheck where the objects are in the memory:\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\naddress(matrix_A)\naddress(matrix_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f757dffc010\"\n[1] \"0x7f757dffc010\"\n```\n:::\n:::\n\n\n. . .\n\nWhat happens if we modify a value in one of the matrices?\n\n. . .\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmatrix_B[1,1] <- 1\naddress(matrix_A)\naddress(matrix_B)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x7f757dffc010\"\n[1] \"0x7f757d7fb010\"\n```\n:::\n:::\n\n\n## Avoid copying by allocating memory\n\n### No memory allocation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf1 <- function(to = 3, silent=F) {\n  tmp <- c()\n  for (i in 1:to) {\n    a1 <- address(tmp)\n    tmp <- c(tmp, i)\n    a2 <- address(tmp)\n    if(!silent) { print(paste0(a1, \" --> \", a2)) } \n  }\n}\nf1()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x55ac7e931a10 --> 0x55ac881d5e30\"\n[1] \"0x55ac881d5e30 --> 0x55ac881d6300\"\n[1] \"0x55ac881d6300 --> 0x55ac857b19e8\"\n```\n:::\n:::\n\n\n## Avoid copying by allocating memory cted.\n\n### With allocation\n\n\n::: {.cell}\n\n```{.r .cell-code}\nf2 <- function(to = 3, silent = FALSE) {\n  tmp <- vector(length = to, mode='numeric')\n  for (i in 1:to) {\n    a1 <- address(tmp)\n    tmp[i] <- i\n    a2 <- address(tmp)\n    if(!silent) { print(paste0(a1, \" --> \", a2)) }\n  }\n}\nf2()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"0x55ac85dc0208 --> 0x55ac85dc0208\"\n[1] \"0x55ac85dc0208 --> 0x55ac85dc0208\"\n[1] \"0x55ac85dc0208 --> 0x55ac85dc0208\"\n```\n:::\n:::\n\n\n## Allocating memory -- benchmark.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/revealjs/unnamed-chunk-5_b0a73da6db72f0c8e3cbf747ad3cd762'}\n\n```{.r .cell-code}\nlibrary(microbenchmark)\nbenchmrk <- microbenchmark(f1(to = 1e3, silent = T), \n                           f2(to = 1e3, silent = T), \n                           times = 100L)\nggplot2::autoplot(benchmrk)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-revealjs/unnamed-chunk-5-1.png){fig-align='center' width=960}\n:::\n:::\n\n\n## GPU\n\n\n::: {.cell hash='index_cache/revealjs/gpu_R_6fb387704fc8b7a74effe3d0c57e95c1'}\n\n```{.r .cell-code}\nlibrary(gpuR)\nlibrary(microbenchmark)\nA = matrix(rnorm(1000^2), nrow=1000) # stored: RAM, computed: CPU\nB = matrix(rnorm(1000^2), nrow=1000) \ngpuA = gpuMatrix(A, type = \"float\") # stored: RAM, computed: GPU\ngpuB = gpuMatrix(B, type = \"float\")\nvclA = vclMatrix(A, type = \"float\") # stored: GPU, computed: GPU\nvclB = vclMatrix(B, type = \"float\")\nbch <- microbenchmark(\n  cpuC = A %*% B,\n  gpuC = gpuA %*% gpuB,\n  vclC = vclA %*% vclB, \n  times = 10L) \n```\n:::\n\n\n[More on [Charles Determan's Blog](https://www.r-bloggers.com/r-gpu-programming-for-all-with-gpur/).]{.smaller}\n\n## GPU cted.\n\n\n::: {.cell layout-align=\"center\" hash='index_cache/revealjs/unnamed-chunk-6_6d4a848080e5f0f058dcc311c89a89fa'}\n\n```{.r .cell-code}\nggplot2::autoplot(bch)\n```\n:::\n\n\n## Parallelization using package `parallel`\n\nEasiest to parallelize is `lapply`:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nresult <- lapply(1:2, function(x) { c(x, x^2, x^3) } )\nresult\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1\n\n[[2]]\n[1] 2 4 8\n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(parallel)\nnum_cores <- detectCores() - 1\ncl <- makeCluster(num_cores) # Init cluster\nparLapply(cl, 1:2, function(x) { c(x, x^2, x^3)} )\nstopCluster(cl)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[[1]]\n[1] 1 1 1\n\n[[2]]\n[1] 2 4 8\n```\n:::\n:::\n\n\n## {background-image=\"../../assets/images/cover.jpg\"}\n\n### Thank you! Questions?\n\n\n::: {.cell}\n::: {.cell-output .cell-output-stdout}\n```\n         _                     \nplatform x86_64-conda-linux-gnu\nos       linux-gnu             \nmajor    4                     \nminor    2.2                   \n```\n:::\n:::\n\n\n[2023 • [SciLifeLab](https://www.scilifelab.se/) • [NBIS](https://nbis.se/) • [RaukR](https://nbisweden.github.io/workshop-RaukR-2306/)]{.smaller}",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {
      "include-in-header": [
        "<script src=\"../../site_libs/htmlwidgets-1.6.1/htmlwidgets.js\"></script>\n<link href=\"../../site_libs/datatables-css-0.0.0/datatables-crosstalk.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/datatables-binding-0.27/datatables.js\"></script>\n<script src=\"../../site_libs/jquery-3.6.0/jquery-3.6.0.min.js\"></script>\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.min.css\" rel=\"stylesheet\" />\n<link href=\"../../site_libs/dt-core-1.12.1/css/jquery.dataTables.extra.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/dt-core-1.12.1/js/jquery.dataTables.min.js\"></script>\n<link href=\"../../site_libs/crosstalk-1.2.0/css/crosstalk.min.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/crosstalk-1.2.0/js/crosstalk.min.js\"></script>\n<script src=\"../../site_libs/d3-3.5.6/d3.min.js\"></script>\n<link href=\"../../site_libs/profvis-0.3.6.9000/profvis.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/profvis-0.3.6.9000/profvis.js\"></script>\n<script src=\"../../site_libs/profvis-0.3.6.9000/scroll.js\"></script>\n<link href=\"../../site_libs/highlight-6.2.0/textmate.css\" rel=\"stylesheet\" />\n<script src=\"../../site_libs/highlight-6.2.0/highlight.js\"></script>\n<script src=\"../../site_libs/profvis-binding-0.3.7/profvis.js\"></script>\n"
      ],
      "include-after-body": [
        "\n<script>\n  // htmlwidgets need to know to resize themselves when slides are shown/hidden.\n  // Fire the \"slideenter\" event (handled by htmlwidgets.js) when the current\n  // slide changes (different for each slide format).\n  (function () {\n    // dispatch for htmlwidgets\n    function fireSlideEnter() {\n      const event = window.document.createEvent(\"Event\");\n      event.initEvent(\"slideenter\", true, true);\n      window.document.dispatchEvent(event);\n    }\n\n    function fireSlideChanged(previousSlide, currentSlide) {\n      fireSlideEnter();\n\n      // dispatch for shiny\n      if (window.jQuery) {\n        if (previousSlide) {\n          window.jQuery(previousSlide).trigger(\"hidden\");\n        }\n        if (currentSlide) {\n          window.jQuery(currentSlide).trigger(\"shown\");\n        }\n      }\n    }\n\n    // hookup for slidy\n    if (window.w3c_slidy) {\n      window.w3c_slidy.add_observer(function (slide_num) {\n        // slide_num starts at position 1\n        fireSlideChanged(null, w3c_slidy.slides[slide_num - 1]);\n      });\n    }\n\n  })();\n</script>\n\n"
      ]
    },
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}