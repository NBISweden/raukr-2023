{
  "hash": "24598f6cf6dabd0dd6deab5b7c4947f8",
  "result": {
    "markdown": "---\ntitle: \"R packages\"\nauthor: \"Sebastian DiLorenzo\"\ndescription: \"Building packages in R.\"\nimage: \"assets/featured.jpg\"\nformat: html\n---\n\n::: {.cell}\n\n:::\n\n\n::: {.callout-note}\nThis is the R packages exercise from RaukR.\nIt will take you through creating an R package with code, data, documentation, creating or generating a correct DESCRIPTION and NAMESPACE, importing packages, checking your package for warnings.\nThere are also some advanced exercises you can do if you have time.\n\nThe exercise will show how to do things from R console, but many of the functionality are so common they are built into Rstudio.\nBecause of this I have included a cheatsheet which can be useful if you are developing packages in Rstudio in the future.\n\nIt is fine if you do not have time for the whole thing, as all components may not be important to you.\nYou can always come back later :).\n:::\n\n## Cheatsheet\n\n\n::: {.cell-output-display}\nTable: Cheatsheet. Note; not all commands are functionally equivalent to Rstudio commands.\n\n|command                   |description                                                                                         |Rstudio_windows                                |Rstudio_mac                                    |\n|:-------------------------|:---------------------------------------------------------------------------------------------------|:----------------------------------------------|:----------------------------------------------|\n|usethis::create_package() |Create a package backbone.                                                                          |File > New Project > New Directory > R package |File > New Project > New Directory > R package |\n|usethis::use_r()          |Create or open a file in R/ for editing.                                                            |NA                                             |NA                                             |\n|devtools::load_all()      |Simulates building, installing and attaching a development package.                                 |CTRL+SHIFT+L                                   |CMD+SHIFT+L                                    |\n|usethis::use_data()       |Creates a .rda file in data/ containing the object. The file has the same name as the object.       |NA                                             |NA                                             |\n|devtools::document()      |Create .Rd files from roxygen2 function comments. Generate NAMESPACE.                               |CTRL+SHIFT+D                                   |CMD+SHIFT+D                                    |\n|devtools::use_package()   |Add package to Imports field of DESCRIPTION.                                                        |NA                                             |NA                                             |\n|devtools::check()         |Run R CMD check on your development package from within R. Also performs bundling and other checks. |NA                                             |NA                                             |\n:::\n\n\n## Installing dependencies\n\nThe first thing we want to do is install the dependencies required for the exercise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(c(\"devtools\",\"usethis\",\"roxygen2\", \"knitr\", \"rmarkdown\", \"reshape2\", \"Rcpp\"))\n```\n:::\n\n\nIf you haven't already, install [RStudio](https://posit.co/download/rstudio-desktop/).\n\n## Create a package backbone\n\nFirst of all we will create the standard files that are required in an R package.\n\n\n```{=html}\n<!-- You can do this from within Rstudio **or** using `devtools`. \n\n### Option 1: In Rstudio\n\nSelect *File > New Project > New Directory > R package*, give your package a name and click *Create Project*. This should trigger your Rstudio to reload, showing your package name in the top right corner, your packages file structure in the file viewer and a standard **hello.R** R code file in the editor.\n\n### Option 2: In R devtools suite\n\n-->\n```\n\n    usethis::create_package(\"path/to/your/package/packagename\")\n\nIf you execute this command from within Rstudio, it should open a new instance of Rstudio located within your newly created package.\nIf you didn't and want to work on your package in Rstudio, double click the **.Rproj** file or select it from Rstudio.\n\nTake a look at the \"Files\" pane of Rstudio to see what `create_package()` actually created for you.\n\n## Insert wondrous things\n\nNow that we have a R package backbone lets fill it with stuff!\n\n### R code\n\nLet's create the first function of your package.\nWe can use the handy helper-function `usethis::use_r()` to create or navigate between the R files in your **R/** folder.\nYou can also just create a **.R** file there if you wish.\n\n```\nusethis::use_r(\"trianguletter\")\n```\n\nThis should create and open the file `R/trianguletter.R` for editing.\n\nFeel free to rewrite the function to perform some simple task.\nFrom adding two numbers to creating a basic plot from some input.\nIt's up to you!\n\nHere is an example that I threw together:\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrianguletter <- function(x) {\n  for(i in 1:x){\n    cat(rep( letters[i], times = i),\"\\n\")\n  }\n}\n```\n:::\n\n\nWhen you are happy with your function, save it.\nTo access and test your newly created function we have to attach it to make it available.\nBut rather than bundle, install and attach we can use the function `devtools::load_all()` while developing the package.\n`load_all()` simulates the behavior of bundling, installing and attaching the package, without actually having to do it.\n\nNow test your function in the console!\n\n\n::: {.cell}\n\n```{.r .cell-code}\ntrianguletter(12)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \nb b \nc c c \nd d d d \ne e e e e \nf f f f f f \ng g g g g g g \nh h h h h h h h \ni i i i i i i i i \nj j j j j j j j j j \nk k k k k k k k k k k \nl l l l l l l l l l l l \n```\n:::\n:::\n\n\n**Congratulations!** You have just created an R package that fulfills a function!\n\n### Data\n\nLets add some data to our package, create an R object with whatever information you want.\nA string, a vector or a data.frame, as long as you recognize it, it doesn't matter.\nFirst we will save it to our **data/** folder using `usethis::use_data()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# A random object\nyour_object <- c('red','green','blue')\n\n#Save to data\nusethis::use_data(your_object)\n```\n:::\n\n\nThis created the **data/** folder and **your_object.rda** inside it.\n\n<!-- Notice that we are not giving it our packages location. This is because it will default to using the package in the working directory, if your current R session is not in the package root it will complain. -->\n\n\n\n\n\nNow when our package is loaded, `your_object` will be made available to the user.\nTo test this, remove all objects from your working directory, and load all functions.\nCheck that you can access the object, despite just removing it from your workspace.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear workspace\nrm(list=ls())\n\n# Load all functions and data from our package\ndevtools::load_all()\n\n# Check if we can access our saved object\nyour_object\n[1] \"red\"   \"green\" \"blue\"\n```\n:::\n\n\nThe data in **data/** folder is available to the user, needs to be documented, and is where you would store data if the purpose of your package is to distribute one or more datasets in an R friendly way.\nIf there is some data that you don't want to make easily accessible to the users, AKA not document, but that your functions use, you can put it in **sysdata.rda**.\nLets create a second object.\nLike the last one it does not matter what it is.\nUse the same command as before to save the object, except this time specify that this data is intended for internal use.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Create a second object\nsecond_object <- \"It works!\"\n\n# Save it to R/sysdata.rda\nusethis::use_data(second_object, internal = TRUE)\n```\n:::\n\n\nTo check that this worked, clear your workspace and edit your packages function, the **.R** file, to include the object in some way.\nLoad the package and see if it executes as expected.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# Clear workspace\nrm(list=ls())\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Example .R code edit\ntrianguletter <- function(x) {\n  for(i in 1:x){\n    cat(rep( letters[i], times = i),\"\\n\")\n  }\n  # Check if second object can be called by our function\n  cat(second_object)\n}\n```\n:::\n\n::: {.cell}\n\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Load all functions and data from our package\ndevtools::load_all()\n```\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\n# Test the function\ntrianguletter(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\na \nb b \nc c c \nd d d d \ne e e e e \nIt works!\n```\n:::\n:::\n\n\nGreat work!\nYou have created external and internal datasets and shown that they can be used when your package is loaded in the console and in your packages own functions!\n\n### Documentation\n\nNow that we have a function and a dataset, lets use `roxygen2` to create some documentation for them.\n\n#### Function documentation\n\nAs was discussed in the presentation, the `roxygen2` documentation for a function is directly before it in so called \"comment blocks\", or `#'`.\nHere is a brief refresher:\n\n- Comment block : `#'`\n- Tags : `@tagname`\n  - `@param` : parameter\n  - `@example` : examples\n  - `@return` : what does the function return. The *value* field in R documentation\n  - `@section` : create any section you want\n  - `@export` : export the function so it can be used externally\n\nGo ahead and create documentation for your function.\nAdd at least a title, a description, multi-section details, the parameters, the expected return value or output, an example of how to use your function and the export tag.\n\n::: {.callout-note}\nThe `@export` tag should always be last in documentation and grants the user access to the function.\nIt is very important, if you want the user to be able to call the function.\nFor internal functions, this may not be the case.\n:::\n\nAn example functional documentation:\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' A right sided triangle of alphabetic letters\n#'\n#' A right sided triangle of alphabetic letters\n#'\n#' This function takes a number as input and outputs an increasing\n#'     number of alphabetic letters on top of each other, resembling\n#'     a right sided triangle.\n#' @section Warning:\n#' Not tested for numbers over 26!\n#'\n#' @param x A number.\n#' @return Outputs to console. NULL object returned.\n#' @examples\n#' trianguletter(10)\n#' @export\ntrianguletter <- function(x) {\n  for(i in 1:x){\n    cat(rep( letters[i], times = i),\"\\n\")\n  }\n  # Check if second object can be called by our function\n  cat(second_object)\n}\n```\n:::\n\n\nWhen you are satisfied with your documentation, build it using `devtools::document()`.\nThis creates the **.Rd** file in **man/** which is parsed by R when you request the functions documentation.\nAdditionally, the first time you build documentation it will make some edits to your **DESCRIPTION** and check on your **NAMESPACE**.\n\n::: {.callout-tip}\nYou may have gotten a warning message that your NAMESPACE was not generated by roxygen2.\nThis is good behavior by roxygen2, it doesn't want to change something the user has created a certain way.\nIn this case however, we want the NAMESPACE to be handled by roxygen2, so delete the NAMESPACE file and run `devtools::document()` again to have roxygen2 create it.\n:::\n\nGo ahead and preview your function as you would any method and make sure that it looks the way you were expecting.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?trianguletter\n```\n:::\n\n\n![](assets/trianguletterRd.png)\n\n#### Data documentation\n\nData documentation is a bit different from functional documentation.\nRemember that you do not need to document datasets not intended for users, so don't worry about **sysdata.rda**.\nWhat we want to document in this case is the data you created in **man/your_object.rda**, or whichever name you have given it.\n\nThe principle is very similar to functional documentation, but not all tags that are applicable to functions are applicable to data, and should not be used.\nSimilarly, there are some tags that are applicable to data, but not to functions.\nUsually this is the information you would give a dataset:\n\n- Data documentation\n  - Title\n  - Description\n  - `@format` : what rows and variables are in the data?\n  - `@source` : where is the data from?\n\nFirst of all, lets check what the output of requesting help for your dataset is currently.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?your_object\n```\n:::\n\n\nAs expected, it is undocumented.\nSince we cannot add this information to the dataset file, **your_object.rda**, like we did with the functions documentation, lets create an R file in **R/** called **data.R** and add the documentation there.\nThe name we document has to be the same name as the dataset object you created earlier.\nGo ahead and document your dataset now.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' A vector with three strings\n#'\n#' A dataset containing three strings usually linked to the\n#'    colors of pixels on a screen.\n#'\n#' @format A vector with three strings:\n#' \\describe{\n#'   \\item{red}{A string, it's red.}\n#'   \\item{green}{A string, it's green. Street talk for money.}\n#'   \\item{blue}{A string, really didn't see that coming. It's blue this time!}\n#' }\n#' @source \\url{http://www.themindofsebastian.com}\n\"your_object\"\n```\n:::\n\n\nOnce you are happy with your documentation, save the file and run `devtools::document()`. Now check the help page for your dataset again.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n?your_object\n```\n:::\n\n\n![](assets/your_object.png)\n\nWell done! You have successfully created documentation for a function and a dataset and shown that it can be queried within R.\n\n\n### DESCRIPTION\n\nNow lets take a look at our **DESCRIPTION** file, at this point it should look similar to this:\n\n    Package: newpkg\n    Title: What the Package Does (One Line, Title Case)\n    Version: 0.0.0.9000\n    Authors@R: \n        person(\"First\", \"Last\", , \"first.last@example.com\", role = c(\"aut\", \"cre\"),\n               comment = c(ORCID = \"YOUR-ORCID-ID\"))\n    Description: What the package does (one paragraph).\n    License: `use_mit_license()`, `use_gpl3_license()` or friends to pick a\n        license\n    Encoding: UTF-8\n    Roxygen: list(markdown = TRUE)\n    RoxygenNote: 7.2.0\n    Depends: \n        R (>= 2.10)\n    LazyData: true\n\n::: {.callout-note}\nThe information can look slightly different depending on how the package was created.\n:::\n\nLooks pretty good but some information definitely needs to be updated if you are ever going to submit this to a repository.\n\nUpdate the *Title*, *Author* and *Description* fields.\n\nWhen it comes to the *License* field, Just in case you don't want to consider which license to give your package, why not choose one of the most common ones that were mentioned during the lecture?\n\n- MIT : Free, but your license must be included in any following work.\n- GPL-3 : Even more free. If someone uses your code, whatever they are doing must also be GPL compatible.\n- CC0 : Totally free.\n\nOne good way of adding the license is not to just update the **DESCRIPTION**, but to use a function such as `use_mit_license()`. It not only updates your **DESCRIPTION**, but also adds the file **LICENSE** and **LICENSE.md** to your package, with relevant license information.\n\nA good place to look at the meaning of licenses is [https://tldrlegal.com](https://tldrlegal.com).\n\nNow that your **DESCRIPTION** is up to shape, we can move on to the **NAMESPACE**.\n\n### NAMESPACE\n\nRoxygen2 made our function available to the users in our **NAMESPACE** and made sure that our package works well with other packages. Basically, you should almost never be editing your **NAMESPACE** by hand.\n\n#### Import\n\nFirst, lets import a function from a package and add its functionality to the function we created. This is very handy for using functions from other packages in your package and for making sure your package uses only that function when it is called, no matter the users environment.\n\n1. Create a new file called **R/utility.R**. We won't actually put any internal utility functions there, but this is a typical place where you would import functions from other packages.\n2. Next add code to import the `melt` function from `reshape2`. This is in the form `@importFrom pkg function`. Since this kind of documentation has to precede a function or object, we will give it the **NULL** object, by convention.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' @importFrom reshape2 melt\nNULL\n```\n:::\n\n\nTo update the **NAMESPACE** run `devtools::document()`.\n\nNow your **NAMESPACE** should look like this:\n\n```\n# Generated by roxygen2: do not edit by hand\n\nexport(trianguletter)\nimportFrom(reshape2,melt)\n```\n\nGreat! If the `melt` command from `reshape2` is ever used in your package, it will know which one to use. But for our package to use `reshape2` we first have to import it in **DESCRIPTION**.\n\nTo add the `Imports` field and the `reshape2` information to your **DESCRIPTION** you can use the `usethis::use_package` command.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_package(\"reshape2\")\n```\n:::\n\n\nWhile `Imports` means that if someone installs your package it will automatically install `reshape2` as well, regrettably it does not mean that if `reshape2` is missing when we reinstall it locally it will be downloaded and installed. Luckily we installed it at the start of the exercise.\n\n#### Testing the imported function\n\nNow that we have added `melt` from `reshape2` lets add it to our function. You can do this any way you like, or copy usage from the example function.\n\nIn this example the `head` of `iris` dataset before and after `melt` is viewed, to see that it had an effect.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n#' A right sided triangle of alphabetic letters\n#'\n#' A right sided triangle of alphabetic letters\n#'\n#' This function takes a number as input and outputs an increasing\n#'     number of alphabetic letters on top of eachother, resembling\n#'     a right sided triangle.\n#' @section Warning:\n#' Not tested for numbers over 26!\n#'\n#' @param x A number.\n#' @return Outputs to console. NULL object returned.\n#' @examples\n#' trianguletter(10)\n#' @export\ntrianguletter <- function(x) {\n  for(i in 1:x){\n    cat(rep( letters[i], times = i),\"\\n\")\n  }\n  # Check if second object can be called by our function\n  #cat(second_object)\n  #what iris dataset looks like\n  cat(\"before melt:\\n\")\n  print(head(iris))\n  #Use melt and see what it looks like\n  cat(\"after melt:\\n\")\n  print(head(melt(iris)))\n}\n```\n:::\n\n\nUse `devtools::load_all()` to reload your package and it's imports. You can check that `reshape2` was also loaded with `sessionInfo()`.\n\nTest your function, does the output show that it can use `melt`?\n\nNow, lets check that the NAMESPACE is doing what we want it to do, making sure that the correct `melt` is being used by our package. Lets define a new function, also named `melt`, in our global environment. That is to say we just define it from the R console.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmelt <- function(x) {\n   cat(\"abc\",x)}\n```\n:::\n\n\nNow try your function again. Is it using the correct `melt`?\n\nIt should be!\n\nTry using `melt(iris)` in your R console, as it is used in your packages function. It should not work. This is because it is using the `melt` function you just defined, and it is getting in the way of using the correct function!\n\n::: {.callout-note}\nAn alternative way of achieving the behaviour of a correct NAMESPACE is writing your code with strict package references. In our case `reshape2::melt()`. This way you can circumvent using `roxygen2` to add import tags to `NAMESPACE` if you want. I recommend doing both =).\n:::\n\n## Checking your package\n\nNow that we have a pretty complete package, lets run some checks on it. You can use the standard `R CMD check pkgname` from your terminal, or you can use `devtools::check()`, which we recommend, as it performs some additional operations such as updating the documentation and bundling the package before checking.\n\n    ── R CMD check results ───────────────────────────────── newpkg 0.0.0.9000 ────\n    Duration: 18.1s\n\n    ❯ checking R code for possible problems ... NOTE\n      trianguletter: no visible global function definition for ‘head’\n      trianguletter: no visible binding for global variable ‘iris’\n      Undefined global functions or variables:\n        head iris\n      Consider adding\n        importFrom(\"datasets\", \"iris\")\n        importFrom(\"utils\", \"head\")\n      to your NAMESPACE file.\n\n    0 errors ✔ | 0 warnings ✔ | 1 note ✖\n\nDid you get any **NOTE**s, **ERROR**s or **WARNING**s? I know I did! Among other things it didn't like my usage of the `iris` dataset without specifying it in the NAMESPACE. This one is a bit tricky, but you can try to solve it if you want.\n\n## Finish line\n\n![](assets/small_package.jpg){width=\"40%\"}\n\nWell done! You have built a functional package. Maybe it is even time to update the version number in **DESCRIPTION** and take it out of development?\n\nIf you want to know even more about this topic, I recommend Hadley Wickham and Jenny Bryan's excellent online resource [http://r-pkgs.had.co.nz/check.html](http://r-pkgs.had.co.nz/check.html).\n\nThe next sections are optional and cover vignettes, testing,  including C++ code in your package using `Rcpp` and pushing your R package to github and setting up github actions for it.\n\n## Vignette\n\nVignettes are long-form documentation for your package. Like a manual detailing what the purpose of your package and its functions are.\n\nTo initialize your vignette, you can use the command:\n\n```\nusethis::use_vignette(\"packagename_vignette\")\n```\n\nWhat this does:\n\n1. Creates the **vignettes/** folder with **packagename_vignette.Rmd** inside\n2. Edits your **DESCRIPTION**, adding `knitr` to `Suggests` and as a `VignetteBuilder`.\n\nOpen the file **vignettes/packagename_vignette.Rmd**, unless it was already automatically opened when using the command. Edit the header data, change `title` and add an `author`, then create a minimal vignette for your function. Do run your function and show your dataset using `knitr` from the vignette. It can be as short as you want, however if you do this for a real package it should be a long form manual showing how your package can use its functions or data to perform the task it was designed for.\n\n::: {.callout-note}\nTo be able to use the functions of your package in the vignette you will need to install your package, the easiest way is to execute `devtools::install()`.\n:::\n\nTo preview your vignette while working on it, press the *knit* button in Rstudio.\n\nExample **vignette.Rmd**:\n\n````\n---\ntitle: \"How to write more and more letters, in a triangle\"\nauthor: \"Sebastian DiLorenzo\"\ndate: \"2023-03-26\"\noutput: rmarkdown::html_vignette\nvignette: >\n  %\\VignetteIndexEntry{How to write more and more letters, in a triangle}\n  %\\VignetteEngine{knitr::rmarkdown}\n  %\\VignetteEncoding{UTF-8}\n---\n\n```{{r setup, include=FALSE}}\nknitr::opts_chunk$set(\n  collapse = TRUE,\n  comment = \"#>\"\n)\n\n# replace this with your package name\nlibrary(newpkg)\n```\n\n# The greatest package for a very specific purpose\n\nIf you thought that it was impossible to write letters\nalphabetically from top to bottom with each number represented\nthe same number of times asits position in the alphabet\n  - think again!\n\nThis package and its sole function, trianguletter, solves just this problem!\n\nBut you do not have to take my word for it, see for yourself:\n\n```{{r}}\n# With just a simple number we specify how long into the alphabet we go.\ntrianguletter(10)\n\n# Also, this package has this random dataset:\nyour_object\n```\n\n# Future plans\n\nWe plan to add features so that you can give it\na letter, rather than a number, and output a\nbunch of numbers instead!\n\n````\n<!-- > Note: Because I am writing this in rmarkdown I added backslashes before the code or it would not render properly for this exercise instruction. In your rmarkdown there should **not** be backslashes before code chunks.  See the \\\\``` in the vignette code. -->\n\nAnd the beautiful rendered version:\n\n![](assets/vignette.png)\n\nThe preview you get when knitting the **vignette.Rmd** does not mean that the vignette has been created. When you are happy with the vignette, use `devtools::build_vignettes()`. To view the vignette as an external user would view it is for some reason a bit of a hassle for the package you are developing, perhaps because the output is pretty much the same as when you knit. If you want to do this you can build your package source with `devtools::build()`, which also builds the vignette, and then `devtools::load_all()`. Then view the vignette with `browseVignettes(\"packagename\")`.\n\nOnce again, good work! Now you have written a short guide to your package that will be included wherever it goes!\n\n## Testing\n\nTesting is a powerful way to add tests to your package. They can for example make sure that the output from your functions are as you expect them to be. This can be very good when you have many people working on a package, such as open source. It is not hard to imagine a situation where someone makes a change that has unforseen consequences and even if the function doesn't throw an error the output has changed leading to errors in the next function that are hard to track.\n\nTo add tests to your package you can use\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_testthat()\n```\n:::\n\n\nBe sure to check the output from the command as it describes what it does to your package very well. As it suggests we can now use `usethis::use_test()` to create a template test for a function.\n\nWe will create a new function to test, since `trianguletter()` uses `cat()` which is standard output, it is advanced to run tests on it. As always you are free and encouraged to create your own function. The example is for inspiration.\n\nCreate a new function in `R/divider.R`\n\n\n::: {.cell}\n\n```{.r .cell-code}\nusethis::use_r(\"trivider\")\n```\n:::\n\n\nAnd define the function.\n\n```\ntrivider <- function(x){\n  x / 3\n}\n```\n\nNow lets create the test using:\n\n```\nusethis::use_test(\"trivider\")\n```\n\nThis creates the file **tests/testthat/test-trivider.R**, which is where we will write our tests for that function.\nNow we can for example write a test that makes sure the input *9* results in the output *3*.\n\n```\ntest_that(\"given a 9 the output is 3\", {\n  expect_equal(trivider(9), 3)\n})\n```\n\nYou can run the test by using the command\n\n```\ndevtools::test()\n```\n\nTry adding another test in **test-trivider.R**, or whichever function you are using. Use `expect_error()` this time. Can you get a PASS on both your tests?\n\nImportantly, your tests are performed when you run `devtools::check()`, which means that you have just extended its functionality to keep a closer eye on your packages expected behaviour.\n\n## src/ and Rcpp\n\nR is not always the most efficient language, which is why it is great that we can integrate other code with our package. Either using ready made solutions, or by including a script file of another language in the package.\n\nHere we will integrate the well developed `Rcpp` package to be able to use C++ code in our package.\n\nSimilarly to how we created the package, the first thing we want to do is setup our package to accept `Rcpp`. We can do this with `usethis::use_rcpp()` which does four things:\n\n1. Creates **src/** folder, unless it already exists.\n2. Edits **DESCRIPTION**, adding `Rcpp` to `Imports` and `LinkingTo`.\n3. Create and modify **.gitignore** to not include compiled files (useful if you connect your package to git)\n4. Let's you know two roxygen tags that need to be included, like our documentation, somewhere in package.\n\n::: {.callout-tip}\nSome users have reported receiving some warnings when executing `usethis::use_rcpp()` but it didn't seem to break anything.\n:::\n\n```\nusethis::use_rcpp()\n```\n\nLets include the roxygen tags in our **utility.R** file.\n\n```\n#' @useDynLib newpkg, .registration = TRUE\n#' @importFrom Rcpp sourceCpp\nNULL\n```\n\nNow we are ready to create a C++ file. You can do this from Rstudio to generate a nice template, *File > New file > C++ File*. It should look something like this:\n\n```\n#include <Rcpp.h>\nusing namespace Rcpp;\n\n// This is a simple example of exporting a C++ function to R. You can\n// source this function into an R session using the Rcpp::sourceCpp\n// function (or via the Source button on the editor toolbar). Learn\n// more about Rcpp at:\n//\n//   http://www.rcpp.org/\n//   http://adv-r.had.co.nz/Rcpp.html\n//   http://gallery.rcpp.org/\n//\n\n// [[Rcpp::export]]\nNumericVector timesTwo(NumericVector x) {\n  return x * 2;\n}\n\n\n// You can include R code blocks in C++ files processed with sourceCpp\n// (useful for testing and development). The R code will be automatically\n// run after the compilation.\n//\n\n/*** R\ntimesTwo(42)\n*/\n```\n\nYou should not mess with the header, unless you know what you are doing. Here you can write any C++ function you want, either do this or leave it as it is and we will use the included example function, `timesTwo`. The function is exported to R using `// [[Rcpp::export]]`. Importantly, this does not add the function to your **NAMESPACE**. Add documentation to your function in the same way as we have done previously, but with the C++ commenting style of `//'`.\n\n```\n//' Multiply a number by two\n//'\n//' @param x A integer.\n//' @export\n// [[Rcpp::export]]\nNumericVector timesTwo(NumericVector x) {\n  return x * 2;\n}\n```\n\nSave the file to your src/ directory and call `pkgbuild::compile_dll()`, which re-compiles the package, implementing our changes. Now run `devtools::document()` to update your **NAMESPACE**. Lets install and restart using *Cmd/Ctrl + Shift + B* in Rstudio. This will create the file **RcppExports.R** in **R/**, which is what R uses to call your C++ function.\n\nTest that your function works from console.\n\nYour R package can now run C++ code, marvelous! Now you just need to learn C++ ;).\n\n### Check again!\n\n> Added new components to the package have we?\n> - Yoda\n\nPerform `devtools::check()` again and fix any new messages.\n\n## Github and Github actions\n\nThis section does require some previous git knowledge.\n\n### Github\n\nLet's add our R package to github, so we can distribute it! To do this you will need a github account. Since git usage is covered later in the course, you can return to this. But if you want you are very welcome to follow this guide. It does require that you have git installed, accessible and configured on your local computer.\n\nTo initialize git for your R package, so it becomes a local repository, you first need to run the command:\n\n```\nusethis::use_git()\n```\n\nTo initialize a new github repository with the same name as your R package and push your files there, you can use this command:\n\n```\nusethis::use_github()\n```\n\nAt this point, you should have a new repository on your github that has your R package files inside it. This is fantastic! Not only does this mean you can now install your package from any other computer , but we can also setup github actions!\n\nCheck that you can install your package directly from the github repository using a command of the form `devtools::install_github(\"Username/repository_name\")`.\n\n### Github actions\n\n:::{.callout-tip}\nGithub actions are only free for public repositories. Do not create a private repository, for example under your organisation, for this exercise!\n:::\n\nLet's set up our R package so that it will test if it passes R CMD CHECK on three major operating systems.\n\nThe first thing you will need to do is make sure your github account can use actions/workflows. If you are using a personal access token go to *(user, not repo) Settings>Developer settings>Personal access tokens* on your github account and make sure you have selected a *Scope* called *workflow*. \n\nNow lets add an action to our R-package. It is possible to do this manually but luckily there are some example workflows you can use for the most common cases at https://github.com/r-lib/actions/tree/master/examples.\nTo add the action, we will use the `usethis` package, similarly to how we used it to initiate vignettes earlier. Issue the command `usethis::use_github_action(\"check-standard\")` in your R package R session, which will select the standard CI workflow from the link.\n\nWhat this actually did is create the folders and file `.github/workflows/check-standard.yaml` which github will know to look for in a repository for instructions to run actions.\n\nNow commit and push these newly added files to your git repository the *Actions* tab on github will commence running an action, checking your R package for compatibility with several operating systems, as shown below.\n\n![](assets/github_actions.png)\n\nThat is it, now you know all the most important bits about creating an R package. Go make something useful!\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}