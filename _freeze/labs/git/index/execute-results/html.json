{
  "hash": "da5e774b9bda511d8e4ec49c9203c72f",
  "result": {
    "markdown": "---\ntitle: \"git and R\"\nauthor: \"Sebastian DiLorenzo\"\ndescription: \"Work reproducibly and together\"\nimage: \"assets/featured.jpg\"\nformat: html\n---\n\n\n\n\n<!--\nLab outline\n\nMain lab:\nFrom RStudio, create a new R project with git version control.\nConnect to github.\nCreate some R file.\nInsert some code.\nCommit.\nPush.\nGo to repository on github.\nIntroduce some changes.\npull to local.\nInsert some more code.\nCheck out the diff.\nreset to previous commit.\n\nCreate a repository on github.\nClone that repository into Rstudio.\n\nEnd of main lab:\nDelete created repositories on github.\n\n\nLab extras:\nBranches\nMerge conflicts\nForks\npull requests\ngithub actions\n-->\n\n::: {.callout-note}\nThis is the lab on using git and github with R. It will take you through some basic steps to start using git with your R code and how to work with others on the same code. When you are comfortable there are some more exercises showing good to know functionalities of git and github.\n\nThis lab assumes that you have a github account, commandline git and correct git configurations. If you do not and need help, please contact a TA.\n:::\n\n## Install packages\n\nThe first thing we want to do is install the package required for the exercise.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ninstall.packages(\"usethis\")\n```\n:::\n\n\n## Working with git and github starting from RStudio\nLet's go through the common situation of starting a new project and connecting it to git and github. Let's create a mental model for this: Hypothetically, you have just been asked to perform some data analysis, produce some plots, and now it is time to start!\n\n1. In RStudio, create a new project in a new directory. You can initialize it as a git repository upon creation or you can do that after using `usethis::use_git()`.\n\n2. Connect it to github using `usethis::use_github()`.\n\n3. Create an R script in your project and write some code. You are free to do whatever you want here. Write a function, create a plot, use a public dataset. Go crazy!\n\n4. Use the RStudio *git pane* to `commit` your code including a commit message.\n\n![](assets/git_pane.png)\n\n5. `push` the changes to your github repository. Then go to github and check that you can see your changes there. In your mental model, this is you sharing your code with your collaborators or users.\n\n6. Now introduce some changes to your script from github and `commit` them. At this point, your github repository is one `commit` ahead of your local repository. In the mental model, this can be your collaborators making changes in their local repository and `push`ing it to your shared github project, or a user suggesting a change in your publicly available R-package, used by millions. For now, lets ignore thinking about who has access to `commit` to your repository, but do not worry, there are ways to safeguard this. Your code can be open on github without other people being able to ruin it so you have to constantly go back to a previous unruined `commit`!\n\n7. To transfer the changes in the github repository to your local repository, go back to RStudio and use the blue arrow in the *git pane* to `pull` the changes. In the mental model this is you updating your code with the code contributed by your collaborators. Notice here that if if you had in the meantime made some changes to the local repository in the same R script and position as you had on github, there would be what is called a \"merge conflict\" when you tried to `pull`. We will get to those later in the exercise.\n\n8. Let's look at the `diff` operation. Make some changes in your local repository R script again, both removing and adding something, then press the `diff` button in the *git pane*. This should bring up a new window that is similar to the image below. As you can see it clearly shows you what has been added and what has been removed, what the `diff`erence is since your last `commit`.\n\n![](assets/diff.png)\n\n9. Go ahead and `commit` the changes you made. No need to `push` them to github. Now lets go into our mental model and say that you did not like those changes. You have done something you regret, or broken something, and you want to go back. One of the main points of version control after all is the ability to go back. For this you will have to use the *terminal pane* in RStudio. In essence, what you are doing now is using git from the terminal in your local repository, this is because the git operations necessary to go back are not currently built into RStudio. Here are the commands we will be using:\n\n::: {.cell}\n\n```{.bash .cell-code}\ngit reset HEAD~1\ngit restore <our R script>\n```\n:::\n\n\n`git reset HEAD~n` steps you back in your `commit` history `n` `commit`s. In this case `HEAD~1` means *go one `commit` back*. Look at your R script, are the changes you made still there? They should be. You have gone back one `commit`, not removed the changes you made during that `commit`. But now that we are on this `commit` you can `git restore` your R script file to take it back to the way it was at the start of current `commit`. Go ahead and try it out and make sure it works as you would expect it to!\n\nNow you should have all the tools you need to work with git in a basic capacity, starting from a new project on your device. Notice that you do not need to start from a new project, you can also take a folder with lots of work you have already performed and make it an R project and initialize git in it. It will of course only track changes from that point, not what you have done previously, but it is still a good idea!\n\nThe point here being that starting from scratch or starting from a bunch of work that you have already done, or starting by creating a github repository and pulling that into github using *File > New Project > Version Control > Git* , there are tools for any situation and it is not too late to start working reproducibly, collaboratively and with backups using git!\n\n## Additional topics and exercises\n\n### Branches\n\nBranches in git are a way to create a separate version controlled instance of your repository. Think of `add`ing and `commit`ing as a tree trunk, growing as you create more changes but always possible to `reset` and go back down to a lower point on the trunk.  Then `branch`ing is the equivalent of a branch shooting out at a certain point on that trunk with the possibility to grow as you develop that `branch`. This permits you or someone else to work on a separate idea at the same time as you continue to develop the trunk. Say for example that you have a situation where there is a stable release of your R package and you do not want to push changes to this. So you create a `branch` called \"development\" and when you are happy with it you merge that branch back into the trunk!\n\n![](assets/git_branch.png)\n\nUseful commands for branches from terminal:\n\n- `git branch <name of branch>` : Create a new branch.\n- `git branch` : See list of branches. Current branch marked with *.\n- `git checkout <name of branch>` : Move to branch.\n- `git merge <name of branch>` : Merge the branch you are currently on with the branch named in command.\n\nHowever, you can work with branches from RStudio as well! To do this you can use the purpleish button in *git pane* that looks like two squares connected with a diamond. Once you have created a new branch you can switch branches to the right of the branch button in the *git pane*.\n\nExercise:\n\n1. Either create a new git version controlled R project in Rstudio, or continue from your last one.\n2. Create a new branch using RStudio. Make sure you are on that branch afterwards.\n3. Introduce some changes in your R script. `commit` them. In our mental model, this is you developing something experimental until you are satisfied with it.\n4. Switch back to the main branch.\n5. To `merge` the new branch with our main branch we will use the terminal again. In the RStudio terminal perform the `merge`. In the mental model this you being satisfied with the development branch and calling it a stable release, a part of the main body of code!\n\nCongratulations, you now know how to create a branch, switch between branches, and merge the branch back into main. \n\n### Merge conflicts\n\nEarlier we thought about the issue of working changes being introduces in your local copy of a repository and in the github version of the repository at the same time. A so called \"merge conflict\". This can also happen if you are working on two branches, introduce chances in the same places and then try to merge! But you should try not to worry too much about merge conflicts, they can be solved if you know what you are doing.\n\n1. Create a merge conflict by introducing changes in the same part of your code on your main and new branch and then using `git merge <name of branch>`. You will need to switch branches, make changes and commit changes to do this.\n\nThe output you should get from the `merge` is similar to:\n\n::: {.cell}\n\n```{.bash .cell-code}\nAuto-merging file.R\nCONFLICT (content): Merge conflict in file.R\nAutomatic merge failed; fix conflicts and then commit the result.\n```\n:::\n\n\nYou can also use `git status` from terminal to check which file is modified and why.\n\nOnce a merge conflict occurs the file effected is modified to reflect the conflicting areas. It can look something like this:\n\n::: {.cell}\n\n```{.bash .cell-code}\n#Hello world!\"\n\n<<<<<<< HEAD\na <- 2\n\nb <- 2\n=======\na <- 3\n>>>>>>> test\n```\n:::\n\n\nIn this instance it is telling us that in branch named \"test\" `a <- 3`but on our main branch `a <- 2` and `b <- 2` has also been added. To pick which one you want to go with simply delete the `>>,<<,==` notifiers and whichever piece rows of code that you do not want.\nOnce you have done this, finalize the merge by `commit`ing the changed files.\n\n2. Fix your merge conflict and finalize the merge.\n\nGood job! You know know how to resolve merge conflicts!\n\n### Forks\n### pull requests\n### github actions\n",
    "supporting": [],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}