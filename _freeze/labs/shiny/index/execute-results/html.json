{
  "hash": "b5f243c44beeea533a5f8d7bda1f7e82",
  "result": {
    "markdown": "---\ntitle: \"Web apps with Shiny\"\nauthor: \"Roy Francis\"\ndescription: \"Interactive web applications in R.\"\nimage: \"assets/featured.jpg\"\nformat: html\ncode-annotations: hover\n---\n\n\n\n\n::: {.callout-note}\nThis is an introduction to shiny web applications with R. Please follow the exercise to familiarise yourself with the fundamentals. And then you can follow instructions to build one of the two complete apps.\n\n- Code chunks starting with `shinyApp()` can be simply copy-pasted to the RStudio console and run.\n- Generally, complete shiny code is saved as a text file, named for example, as **app.R** and then clicking **Run app** launches the app.\n:::\n\n## UI • Layout\n\nThis is an example to show the layout of widgets on a webpage using shiny functions. `fluidPage()` is used to define a responsive webpage. `titlePanel()` is used to define the top bar. `sidebarLayout()` is used to create a layout that includes a region on the left called side bar panel and a main panel on the right. The contents of these panels are further defined under `sidebarPanel()` and `mainPanel()`.\n\nIn the main panel, the use of tab panels are demonstrated. The function `tabsetPanel()` is used to define a tab panel set and individual tabs are defined using `tabPanel()`. `fluidRow()` and `column()` are used to structure elements within each tab. The width of each column is specified. Total width of columns must add up to 12.\n\n\n::: {.cell .column-page}\n\n```{.r .cell-code}\nlibrary(shiny)\nui <- fluidPage(\n  titlePanel(\"Title Panel\"),\n  sidebarLayout(\n    sidebarPanel(\n      helpText(\"Sidebar Panel\")\n    ),\n    mainPanel(tabsetPanel(\n      tabPanel(\"tab1\",\n               fluidRow(\n                 column(6,helpText(\"Col1\")),\n                 column(6,\n                        helpText(\"Col2\"),\n                        fluidRow(\n                          column(4,style=\"background-color:#b0c6fb\",\n                                 helpText(\"Col1\")\n                          ),\n                          column(4,style=\"background-color:#ffa153\",\n                                 helpText(\"Col2\")\n                          ),\n                          column(4,style=\"background-color:#b1f6c6\",\n                                 helpText(\"Col3\")\n                          )\n                        )\n                 )\n               )\n      ),\n      tabPanel(\"tab2\",\n               inputPanel(helpText(\"Input Panel\"))\n      ),\n      tabPanel(\"tab3\",\n               wellPanel(helpText(\"Well Panel\"))\n      )\n    )\n    )\n  )\n)\n\nserver <- function(input,output){}\nshinyApp(ui=ui,server=server)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-2-1.png){width=672}\n:::\n:::\n\n\n## UI • Widgets • Input\n\nInput widgets are used to accept content interactively from the user. These widgets usually end in `Input` like `selectInput()`. Below are usage examples of several of shiny's built-in widgets. Every widget has a variable name which is accessible through `input$` in the server function. For example, the value of a variable named `text-input` would be accessed through `input$text-input`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  fluidRow(\n    column(6,\n           fileInput(\"file-input\",\"fileInput:\"),\n           selectInput(\"select-input\",label=\"selectInput\",choices=c(\"A\",\"B\",\"C\")),\n           numericInput(\"numeric-input\",label=\"numericInput\",value=5,min=1,max=10),\n           sliderInput(\"slider-input\",label=\"sliderInput\",value=5,min=1,max=10),\n           textInput(\"text-input\",label=\"textInput\"),\n           textAreaInput(\"text-area-input\",label=\"textAreaInput\"),\n           dateInput(\"date-input\",label=\"dateInput\"),\n           dateRangeInput(\"date-range-input\",label=\"dateRangeInput\"),\n           radioButtons(\"radio-button\",label=\"radioButtons\",choices=c(\"A\",\"B\",\"C\"),inline=T),\n           checkboxInput(\"checkbox\",\"checkboxInput\",value=FALSE),\n           actionButton(\"action-button\",\"Action\"),\n           hr(),\n           submitButton()\n    )\n  )\n),\nserver=function(input,output){},\noptions=list(height=900))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-3-1.png){width=672}\n:::\n:::\n\n\n## UI • Widgets • Outputs\n\nSimilar to input widgets, output widgets are used to display information to the user on the webpage. These widgets usually end in `Output` like `textOutput()`. Every widget has a variable name accessible under `output$` to which content is written in the server function. Render functions are used to write content to output widgets. For example `renderText()` is used to write text data to `textOutput()` widget.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\n  ui=fluidPage(fluidRow(column(6,\n             textInput(\"text_input\",label=\"textInput\",value=\"<h3 style='color:red'>Red text</h3>\"),\n             hr(),\n             htmlOutput(\"html_output\"),\n             textOutput(\"text_output\"),\n             verbatimTextOutput(\"verbatim_text_output\"),\n             tableOutput(\"table_output\"),\n             plotOutput(\"plot_output\",width=\"300px\",height=\"300px\")\n      ))),\n  server=function(input, output) {\n    output$html_output <- renderText({input$text_input})\n    output$text_output <- renderText({input$text_input})\n    output$verbatim_text_output <- renderText({input$text_input})\n    output$table_output <- renderTable({iris[1:3,1:3]})\n    output$plot_output <- renderPlot({\n      plot(iris[,1],iris[,2])\n    })\n},\noptions=list(height=700))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-4-1.png){width=672}\n:::\n:::\n\n\nIn this example, we have a text input box which takes user text and outputs it in three different variations. The first output is html output `htmlOutput()`. Since the default text is html content, the output is red colored text. A normal non-html text would just look like normal text. The second output is normal text output `textOutput()`. The third variation is `verbatimTextOutput()` which displays text in monospaced code style. This example further shows table output and plot output.\n\n## Dynamic UI\n\nSometimes we want to add, remove or change currently loaded UI widgets conditionally based on dynamic changes in code execution or user input. Conditional UI can be defined using `conditionalPanel()`, `uiOutput()`/`renderUI()`, `insertUI()` or `removeUI`. In this example, we will use `uiOutput()`/`renderUI()`.\n\nIn the example below, the output plot is displayed only if the selected dataset is **iris**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",\n              choices=c(\"mtcars\",\"faithful\",\"iris\")),\n  tableOutput(\"table_output\"),\n  uiOutput(\"ui\")\n),\n\nserver=function(input,output) {\n  getdata <- reactive({ get(input$data_input, 'package:datasets') })\n  \n  output$ui <- renderUI({\n    if(input$data_input==\"iris\") plotOutput(\"plot_output\",width=\"400px\")\n  })\n  \n  output$plot_output <- renderPlot({hist(getdata()[, 1])})\n  output$table_output <- renderTable({head(getdata())})\n})\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-5-1.png){width=672}\n:::\n:::\n\n\nHere, conditional UI is used to selectively display an output widget (plot). Similarly, this idea can be used to selectively display any input or output widget.\n\n## Updating widgets\n\nWidgets can be updated with new values dynamically. `observe()` and `observeEvent()` functions can monitor the values of interest and update relevant widgets.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",choices=c(\"mtcars\",\"faithful\",\"iris\")),\n  selectInput(\"header_input\",label=\"Select column name\",choices=NULL),\n  plotOutput(\"plot_output\",width=\"400px\")\n),\n\nserver=function(input,output,session) {\n  getdata <- reactive({ get(input$data_input, 'package:datasets') })\n  \n  observe({\n    updateSelectInput(session,\"header_input\",label=\"Select column name\",choices=colnames(getdata()))\n  })\n  \n  output$plot_output <- renderPlot({\n    #shiny::req(input$header_input)\n    #validate(need(input$header_input %in% colnames(getdata()),message=\"Incorrect column name.\"))\n    hist(getdata()[, input$header_input],xlab=input$header_input,main=input$data_input)\n  })\n},\noptions=list(height=600))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-6-1.png){width=672}\n:::\n:::\n\n\nIn this example, the user selects a dataset and a column from the selected dataset to be plotted as a histogram. The column name selection widget must automatically update it's choices depending on the selected dataset. This achieved using `observe()` where the `updateSelectInput()` function updates the selection choices. Notice that a third option `session` is in use in the server function. ie; `server=function(input,output,session)`. And `session` is also the first argument in `updateSelectInput()`. Session keeps track of values in the current session.\n\nWhen changing the datasets, we can see that there is a short red error message. This is because, after we have selected a new dataset, the old column name from the previous dataset is searched for in the new dataset. This occurs for a short time and causes the error. This can be fixed using careful error handling. We will discuss this in another section.\n\n## Isolate\n\nYou might've noticed that shiny tends to update changes immediately as the input widgets change. This may not be desirable in all circumstances. For example, if the apps runs a heavy calculation, it is more efficient to grab all the changes and execute in one step rather than executing the heavy calculation after every input change. To illustrate this, we have an example below where we plot an image which has the title as input text. Try adding a long title to it.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\n  ui=fluidPage(\n    textInput(\"in_title\",label=\"Title\",value=\"Title\"),\n    plotOutput(\"out_plot\")),\n  \n  server=function(input,output) {\n    output$out_plot <- renderPlot({\n      plot(iris[,1],iris[,2],main=input$in_title)\n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-7-1.png){width=672}\n:::\n:::\n\n\nThe plot changes as soon as the input text field is changed. And as we type in text, the image is continuously being redrawn. This can be computationally intensive depending on the situation. A better solution would be to write the text completely without any reactivity and when done, let the app know that you are ready to redraw.\n\nWe can add an action button such that the plot is changed only when the button is clicked.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\n  ui=fluidPage(\n    textInput(\"in_title\",label=\"Title\",value=\"Title\"),\n    actionButton(\"btn_go\",\"Go!\"),\n    plotOutput(\"out_plot\")),\n  \n  server=function(input,output) {\n    output$out_plot <- renderPlot({\n      input$btn_go\n      plot(iris[,1],iris[,2],main=isolate(input$in_title))\n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-8-1.png){width=672}\n:::\n:::\n\n\nNow, changes to any of the input fields do not initiate the plot function. The plot is redrawn only when the action button is clicked. When the action button is click, the current values in the input fields are collected and used in the plotting function.\n\n## Error validation\n\nShiny returns an error when a variable is NULL, NA or empty. This is similar to normal R operation. The errors show up as bright red text. By using careful error handling, we can print more informative and less distracting error messages. We also have the option of hiding error messages.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",\n              choices=c(\"\",\"mtcars\",\"faithful\",\"iris\")),\n  tableOutput(\"table_output\")\n),\n\nserver=function(input, output) {\n  getdata <- reactive({ get(input$data_input,'package:datasets') })\n  output$table_output <- renderTable({head(getdata())})\n},\noptions=list(height=\"350px\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-9-1.png){width=672}\n:::\n:::\n\n\nIn this example, we have a list of datasets to select which is then printed as a table. The first and default option is an empty string which cannot be printed as a table and therefore returns an error.\n\nWe can add an extra line to the above app so that the selected string is validated before running downstream commands in the `getdata({})` reactive function. The function `validate()` is used to validate inputs. `validate()` can be used with `need()` function or a custom function.\n\nBelow we use the `need()` function to check the input. It checks if the input is NULL, NA or an empty string and returns a specified message if TRUE. `try()` is optional and is used to catch any other unexpected errors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",\n              choices=c(\"\",\"mtcars\",\"faithful\",\"iris\")),\n  tableOutput(\"table_output\")\n),\n\nserver=function(input, output) {\n  \n  getdata <- reactive({\n    validate(need(try(input$data_input),\"Please select a data set\"))\n    get(input$data_input,'package:datasets')\n  })\n  \n  output$table_output <- renderTable({head(getdata())})\n},\noptions=list(height=\"350px\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-10-1.png){width=672}\n:::\n:::\n\n\nNow we see an informative gray message (less scary) asking the user to select a dataset.\n\nWe can use a custom function instead of using `need()`. Below, we have created a function called `valfun()` that checks if the input is NULL, NA or an empty string. This is then used in `validate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nvalfn <- function(x) if(is.null(x) | is.na(x) | x==\"\") return(\"Input data is incorrect.\")\n\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",\n              choices=c(\"\",\"mtcars\",\"faithful\",\"iris\")),\n  tableOutput(\"table_output\")\n),\n\nserver=function(input, output) {\n  \n  getdata <- reactive({\n    validate(valfn(try(input$data_input)))\n    get(input$data_input,'package:datasets')\n  })\n  \n  output$table_output <- renderTable({head(getdata())})\n},\noptions=list(height=\"350px\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-11-1.png){width=672}\n:::\n:::\n\n\nThe last option is to simple hide the error. This may be used in situations where there is no input needed from the user. We use `req()` to check if the input is valid, else stop execution there till the condition becomes true.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",\n              choices=c(\"\",\"mtcars\",\"faithful\",\"iris\")),\n  tableOutput(\"table_output\")\n),\n\nserver=function(input, output) {\n  \n  getdata <- reactive({\n    shiny::req(try(input$data_input))\n    get(input$data_input,'package:datasets')\n  })\n  \n  output$table_output <- renderTable({head(getdata())})\n},\noptions=list(height=\"350px\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-12-1.png){width=672}\n:::\n:::\n\n\nAs expected there is no error or any message at all. This is not always the best to use this option as we need the user to do something. An informative message may be better than nothing.\n\nFinally, instead of printing messages about the error or hiding the error, we can try to resolve the errors from the previous section in a more robust manner. `shiny::req(input$header_input)` is added to ensure that a valid column name string is available before running any of the `renderPlot()` commands. Second, we add `validate(need(input$header_input %in% colnames(getdata()),message=\"Incorrect column name.\"))` to ensure that the column name is actually a column in the currently selected dataset.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  selectInput(\"data_input\",label=\"Select data\",choices=c(\"mtcars\",\"faithful\",\"iris\")),\n  selectInput(\"header_input\",label=\"Select column name\",choices=NULL),\n  plotOutput(\"plot_output\",width=\"400px\")\n),\n\nserver=function(input,output,session) {\n  getdata <- reactive({ get(input$data_input, 'package:datasets') })\n  \n  observe({\n    updateSelectInput(session,\"header_input\",label=\"Select column name\",choices=colnames(getdata()))\n  })\n  \n  output$plot_output <- renderPlot({\n    shiny::req(input$header_input)\n    validate(need(input$header_input %in% colnames(getdata()),message=\"Incorrect column name.\"))\n    hist(getdata()[, input$header_input],xlab=input$header_input,main=input$data_input)\n  })\n},\noptions=list(height=600))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-13-1.png){width=672}\n:::\n:::\n\n\nNow, we do not see any error messages. Note that shiny apps on shinyapps.io do not display the complete regular R error message for security reasons. It returns a generic error message in the app. One needs to inspect the error logs to view the actual error message.\n\n## Download • Data\n\nIt is often desirable to let the user down data tables and plots as images. This is done using `downloadHandler()`.\n\nIn the example below, we are downloading a table as a csv text file. We define a button that accepts the action input from the user. The `downloadHandler()` function has the file name argument, and the content argument where we specify the `write.csv()` command. Note that this example needs to be opened in a browser and may not in the RStudio preview. In the RStudio preview, click on **Open in Browser**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\n  ui=fluidPage(\n    selectInput(\"data_input\",label=\"Select data\",\n                choices=c(\"mtcars\",\"faithful\",\"iris\")),\n    textOutput(\"text_output\"),\n    downloadButton(\"button_download\",\"Download\")\n  ),\n\n  server=function(input, output) {\n    \n    getdata <- reactive({ get(input$data_input, 'package:datasets') })\n    output$text_output <- renderText(paste0(\"Selected dataset: \",input$data_input))\n    \n    output$button_download <- downloadHandler(\n      filename = function() {\n        paste0(input$data_input,\".csv\")\n      },\n      content = function(file) {\n        write.csv(getdata(),file,row.names=FALSE,quote=F)\n      })\n  },\n  options=list(height=\"200px\")\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-14-1.png){width=672}\n:::\n:::\n\n\n## Download • Plot\n\nIn this next example, we are downloading a plot. In the content part of `downloadHandler()`, we specify commands to export a PNG image. Note that this example needs to be opened in a browser and may not in the RStudio preview. In the RStudio preview, click on **Open in Browser**.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\n  ui=fluidPage(\n    selectInput(\"data_input\",label=\"Select data\",\n                choices=c(\"mtcars\",\"faithful\",\"iris\")),\n    textOutput(\"text_output\"),\n    plotOutput(\"plot_output\",height=\"300px\",width=\"300px\"),\n    downloadButton(\"button_download\",\"Download\")\n  ),\n\n  server=function(input, output) {\n    \n    getdata <- reactive({ get(input$data_input, 'package:datasets') })\n    output$text_output <- renderText(paste0(\"Selected dataset: \",input$data_input))\n    \n    output$plot_output <- renderPlot({hist(getdata()[,1])})\n  \n  output$button_download <- downloadHandler(\n    filename = function() {\n      paste0(input$data_input,\".png\")\n    },\n    content = function(file) {\n      png(file)\n      hist(getdata()[, 1])\n      dev.off()\n    })\n  },\n  options=list(height=\"500px\")\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-15-1.png){width=672}\n:::\n:::\n\n\n## Interactive documents\n### Shiny in Rmarkdown\n\nShiny interactive widgets can be embedded into Rmarkdown documents. These documents need to be live and can handle interactivity. The important addition is the line `runtime: shiny` to the YAML matter. Here is an example:\n\n````\n---\nruntime: shiny\noutput: html_document\n---\n\n```{{r}}\nlibrary(shiny)\n```\n\nThis is a standard RMarkdown document. Here is some code:\n\n```{{r}}\nhead(iris)\n```\n\n```{{r}}\nplot(iris$Sepal.Length,iris$Petal.Width)\n```\n\nBut, here is an interactive shiny widget.\n\n```{{r}}\nsliderInput(\"in_breaks\",label=\"Breaks:\",min=5,max=50,value=5,step=5)\n```\n\n```{{r}}\nrenderPlot({{\nhist(iris$Sepal.Length,breaks=input$in_breaks)\n}})\n```\n````\n\nThis code can be copied to a new file in RStudio and saved as, for example, **shiny.Rmd**. Then click 'Knit'. Alternatively, you can run `rmarkdown::run(\"shiny.Rmd\")`.\n\n### Shiny in Quarto\n\nShiny widgets can be embedded into quarto documents. The YAML needs to specify `server: shiny` which runs shiny server in the background.\n\n````\n---\ntitle: \"This is a title\"\nformat: html\nserver: shiny\n---\n\n```{{r}}\nsliderInput(\"bins\", \"Number of bins:\", \n            min = 1, max = 50, value = 30)\nplotOutput(\"distPlot\")\n```\n\n```{{r}}\n#| context: server\noutput$distPlot <- renderPlot({\n  x <- faithful[, 2]  # Old Faithful Geyser data\n  bins <- seq(min(x), max(x), length.out = input$bins + 1)\n  hist(x, breaks = bins, col = 'darkgray', border = 'white')\n})\n```\n````\n\nIt is also possible to run individual chunks in shiny using `context` chunk parameter.\n\n````\n```{{r}}\n#| context: server\n```\n````\n\nMore information about using shiny and quarto together is [here](https://quarto.org/docs/interactive/shiny/).\n\n## ggplot2 builder\n\nIn the ggplot2 presentation, we had a [few slides](https://nbisweden.github.io/raukr-2023/docs/slides/ggplot/index.html#/theme-text) with theme customisation. We will try to recreate that as a shiny app, so we can interactively customise a plot.\n\n**Topics covered**\n\n-  UI sidebar layout\n-  Input and output widgets\n-  Using colorpicker widget\n-  Creating plots in a shiny app\n\nThe following R packages will be required for this app: `ggplot2`, `shiny`, `colourpicker`.\n\nBelow is a preview of the complete app.\n\n![](assets/ggplot-builder-3.png)\n\nWe start with a shiny app template with sidebar layout.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nshinyApp(\n  ui=pageWithSidebar(\n    sidebarPanel(),\n    mainPanel()\n  ),\n  server=function(input,output){\n  }\n)\n```\n:::\n\n\nIn the ui part, we will define inputs. Most of the inputs are colours, so we use the `colorInput()` widget from the R package `colorpicker`. The output plot is defined as `plotOutput(\"plot\")`. In the server part, we define a `renderPlot()` function that generates a ggplot object.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(colourpicker)\n\nshinyApp(\n    ui = pageWithSidebar(\n        headerPanel(\"ggplot2 plot builder\"),\n        sidebarPanel(\n            colourInput(\"in_plot_title\", \"Plot title\", value = \"#4daf4a\"),\n            colourInput(\"in_plot_subtitle\", \"Plot subtitle\", value = \"#984ea3\"),\n            colourInput(\"in_legend_title\", \"Legend title\", value = \"#ffff33\"),\n            colourInput(\"in_legend_text\", \"legend text\", value = \"#ff7f00\"),\n            selectInput(\"in_legend_pos\", \"Legend position\", choices = c(\"right\", \"left\", \"top\", \"bottom\"), selected = \"right\"),\n            colourInput(\"in_axis_title\", \"Axis title\", value = \"#e41a1c\"),\n            colourInput(\"in_axis_text\", \"Axis text\", value = \"#377eb8\"),\n            colourInput(\"in_strip_text\", \"Strip text\", value = \"#a65628\"),\n        ),\n        mainPanel(\n            plotOutput(\"plot\")\n        )\n    ),\n    server = function(input, output) {\n\n        output$plot <- renderPlot({\n            ggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n                geom_point() +\n                facet_wrap(~Species) +\n                labs(title = \"Iris dataset\", subtitle = \"Scatterplots of Sepal and Petal lengths\", caption = \"The iris dataset by Edgar Anderson\") +\n                theme_grey(base_size = 16)\n        })\n\n    }\n)\n```\n:::\n\n\n![](assets/ggplot-builder-1.png)\n\nThe input widgets now need to be connected to the ggplot function.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(colourpicker)\n\nshinyApp(\n    ui = pageWithSidebar(\n        headerPanel(\"ggplot2 plot builder\"),\n        sidebarPanel(\n            colourInput(\"in_plot_title\", \"Plot title\", value = \"#4daf4a\"),\n            colourInput(\"in_plot_subtitle\", \"Plot subtitle\", value = \"#984ea3\"),\n            colourInput(\"in_legend_title\", \"Legend title\", value = \"#ffff33\"),\n            colourInput(\"in_legend_text\", \"legend text\", value = \"#ff7f00\"),\n            selectInput(\"in_legend_pos\", \"Legend position\", choices = c(\"right\", \"left\", \"top\", \"bottom\"), selected = \"right\"),\n            colourInput(\"in_axis_title\", \"Axis title\", value = \"#e41a1c\"),\n            colourInput(\"in_axis_text\", \"Axis text\", value = \"#377eb8\"),\n            colourInput(\"in_strip_text\", \"Strip text\", value = \"#a65628\"),\n        ),\n        mainPanel(\n            plotOutput(\"plot\")\n        )\n    ),\n    server = function(input, output) {\n\n        output$plot <- renderPlot({\n            ggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n                geom_point() +\n                facet_wrap(~Species) +\n                labs(title = \"Iris dataset\", subtitle = \"Scatterplots of Sepal and Petal lengths\", caption = \"The iris dataset by Edgar Anderson\") +\n                theme_grey(base_size = 16)+\n                theme(\n                  plot.title=element_text(color=input$in_plot_title),\n                  plot.subtitle=element_text(color=input$in_plot_subtitle),\n                  legend.title=element_text(color=input$in_legend_title),\n                  legend.text=element_text(color=input$in_legend_text),\n                  legend.position=input$in_legend_pos,\n                  axis.title=element_text(color=input$in_axis_title),\n                  axis.text=element_text(color=input$in_axis_text),\n                  strip.text=element_text(color=input$in_strip_text)\n                )\n        })\n\n    }\n)\n```\n:::\n\n\n![](assets/ggplot-builder-2.png)\n\nNow try changing the colours of plot elements and hopefully, it should change. \n\n{{< fa clipboard-list >}}  You can add more options to the input if you like, for example; rectangular elements such as backgrounds.\n\n\n::: {.cell}\n\n```{.r .cell-code  code-fold=\"true\"}\nlibrary(shiny)\nlibrary(ggplot2)\nlibrary(colourpicker)\n\nshinyApp(\n    ui = pageWithSidebar(\n        headerPanel(\"ggplot2 plot builder\"),\n        sidebarPanel(\n            colourInput(\"in_plot_title\", \"Plot title\", value = \"#4daf4a\"),\n            colourInput(\"in_plot_subtitle\", \"Plot subtitle\", value = \"#984ea3\"),\n            colourInput(\"in_legend_title\", \"Legend title\", value = \"#ffff33\"),\n            colourInput(\"in_legend_text\", \"legend text\", value = \"#ff7f00\"),\n            selectInput(\"in_legend_pos\", \"Legend position\", choices = c(\"right\", \"left\", \"top\", \"bottom\"), selected = \"right\"),\n            colourInput(\"in_axis_title\", \"Axis title\", value = \"#e41a1c\"),\n            colourInput(\"in_axis_text\", \"Axis text\", value = \"#377eb8\"),\n            colourInput(\"in_strip_text\", \"Strip text\", value = \"#a65628\"),\n            colourInput(\"in_plot_background\", \"Plot background\", value = \"#b3e2cd\"),\n            colourInput(\"in_panel_background\", \"Panel background\", value = \"#fdcdac\"),\n            colourInput(\"in_panel_border\", \"Panel border\", value = \"#cbd5e8\"),\n            colourInput(\"in_legend_background\", \"Legend background\", value = \"#f4cae4\"),\n            colourInput(\"in_legend_box_background\", \"Legend box background\", value = \"#e6f5c9\"),\n            colourInput(\"in_strip_background\", \"Strip background\", value = \"#fff2ae\")\n        ),\n        mainPanel(\n            plotOutput(\"plot\")\n        )\n    ),\n    server = function(input, output) {\n        output$plot <- renderPlot({\n            ggplot(iris, aes(Sepal.Length, Petal.Length, col = Species)) +\n                geom_point() +\n                facet_wrap(~Species) +\n                labs(title = \"Iris dataset\", subtitle = \"Scatterplots of Sepal and Petal lengths\", caption = \"The iris dataset by Edgar Anderson\") +\n                theme_grey(base_size = 16) +\n                theme(\n                    plot.title = element_text(color = input$in_plot_title),\n                    plot.subtitle = element_text(color = input$in_plot_subtitle),\n                    legend.title = element_text(color = input$in_legend_title),\n                    legend.text = element_text(color = input$in_legend_text),\n                    legend.position = input$in_legend_pos,\n                    axis.title = element_text(color = input$in_axis_title),\n                    axis.text = element_text(color = input$in_axis_text),\n                    strip.text = element_text(color = input$in_strip_text),\n                    plot.background = element_rect(fill = input$in_plot_background),\n                    panel.background = element_rect(fill = input$in_panel_background),\n                    panel.border = element_rect(fill = NA, color = input$in_panel_border, size = 3),\n                    legend.background = element_rect(fill = input$in_legend_background),\n                    legend.box.background = element_rect(fill = input$in_legend_box_background),\n                    strip.background = element_rect(fill = input$in_strip_background)\n                )\n        })\n    }\n)\n```\n:::\n\n\n![](assets/ggplot-builder-3.png)\n\n## Data explorer\n\nA common use case of shiny apps is to explore a dataset interactively. So we will build a simple app that can create a scatterplot from a dataframe which a user can modify interactively. We will use the built-in `iris` dataset and the user should be able to select x and y axes variables as well the variable mapped to the color of the points.\n\n**Topics covered**\n\n-   UI sidebar layout\n-   Input and output widgets\n-   Creating plots in a shiny app\n-   Passing variables into ggplot through non standard evaluation\n\nThe following R packages will be required for this app: `ggplot2`, `shiny`.\n\nBelow is a preview of the complete app.\n\n![](assets/data-explorer-2.png)\n\n### UI\n\nWe start with a standard shiny app template.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nshinyApp(\n  ui=fluidPage(),\n  server=function(input,output){}\n)\n```\n:::\n\n\nAnd then we start building the UI. We will add a title panel and a sidebar layout with a sidebar and a main panel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"Data explorer\"),\n    sidebarLayout(\n      sidebarPanel(),\n      mainPanel()\n    )\n  ),\n  server=function(input,output){}\n)\n```\n:::\n\n\n![](assets/data-explorer-1.png)\n\nAnd to the sidebar, we will add 3 input widgets corresponding to x axis variable, y axis variable and color variable. These will be dropdown type (`selectInput()`) and choices will be column names of the iris dataframe. And we add the output widget (`plotOutput()`) in the main panel.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"Data explorer\"),\n    sidebarLayout(\n      sidebarPanel(\n          selectInput(\"in_x\",\"X axis variable\", choices=colnames(iris), selected=colnames(iris)[1], multiple=FALSE),\n          selectInput(\"in_y\",\"Y axis variable\", choices=colnames(iris), selected=colnames(iris)[2], multiple=FALSE),\n          selectInput(\"in_col\",\"Colour variable\", choices=colnames(iris), selected=colnames(iris)[3], multiple=FALSE)\n      ),\n      mainPanel(\n        plotOutput(\"out_plot\")\n      )\n    )\n  ),\n  server=function(input,output){}\n)\n```\n:::\n\n\n![](assets/data-explorer-2.png)\n\n### Server\n\nNow, we need to add the server part. First, we write the ggplot code to create a plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(iris,aes(x,y,col))+\n      geom_point()\n```\n:::\n\n\nThis is added inside the output render function `renderPlot()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$out_plot <- renderPlot({\n    ggplot(iris,aes(x,y,col))+\n      geom_point()\n  })\n```\n:::\n\n\nWe need to wire the input variable into the ggplot inputs x, y and col. This is achieved through `input$` and the variables are wrapped inside `!!sym()` to convert quoted text to unquoted variable.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$out_plot <- renderPlot({\n  ggplot(iris,aes(!!sym(input$in_x),y=!!sym(input$in_y),col=!!sym(input$in_col)))+\n    geom_point()\n})\n```\n:::\n\n\nThis is finally added to the server function.\n\n\n::: {.cell}\n\n:::\n\n\nYou can expand this app to other datasets and map more variables to ggplot etc. Can you add the functionality to [download the plots](https://shiny.rstudio.com/gallery/file-download.html)? Or perhaps to [upload a csv file](https://shiny.rstudio.com/articles/upload.html) and plot from that file?\n\n## Color generator\n\nA shiny app to create a distinct color generator.\n\n**Topics covered**\n\n-   UI layout using bslib\n-   Input and output widgets and reactivity\n-   Use of custom CSS and custom HTML\n\nThe following R packages will be required for this app: `shiny`, `hues`, `bslib`.\n\nBelow is a preview of the finished app.\n\n![](assets/hues-4.png)\n\nThe core function that generates colors is `hues::iwanthue()`. What it does is sample colors from the HCL colorspace. [Here](https://colorspace.r-forge.r-project.org/articles/color_spaces.html) is an introduction to colorspaces and HCL colorspace. It requires the number of colors to generate.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhues::iwanthue(5)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#503F44\" \"#964FB8\" \"#97B2B7\" \"#94BF58\" \"#C6624D\"\n```\n:::\n:::\n\n\nIn addition, this function has six parameters (`hmin`,`hmax`,`cmin`,`cmax`,`lmin`,`lmax`) to control min and max hue, chroma and lightness. This allows you to define where in the HCL colorspace to sample colors from. Hue controls the color wavelength (red, green etc), chroma controls the intensity or saturation of the color and lightness control the brightness.\n\nThis gives you mostly warm reddish colors.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nhues::iwanthue(5,hmin=0,hmax=5,cmin=80,cmax=160,lmin=38,lmax=70)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] \"#B82E53\" \"#D22455\" \"#D34B6A\" \"#F16281\" \"#F22A64\"\n```\n:::\n:::\n\n\nWhat we are creating is a graphical user interface around this function.\n\nIn this example, we will use the `bslib` package to create a bootstrap 5 themed layout using cards. See [bslib](https://rstudio.github.io/bslib/index.html) for more info. This is the structure of the app with cards defined inside a fixed page. See help page for `bslib::card()` for more information on cards. We also define the page title.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(bslib)\n\nshinyApp(\n  ui = page_fixed(\n    title = \"Hues\",\n    card(\n      card_header(),\n      layout_sidebar(\n        sidebar()\n      ),\n      card_footer()\n    )\n  ),\n  server = function(input, output) {\n  }\n)\n```\n:::\n\n\n![](assets/hues-1.png)\n\nNow we define the inputs in the sidebar panel. The number of colors and the three parameters to the colorspace as ranges. Outside the sidebar panel we define our two outputs: an html output to display the names of the colors as hex values. In the footer, we add an acknowledgement link to the hues package.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(hues)\nlibrary(bslib)\n\nshinyApp(\n  ui = page_fixed(\n    title = \"Hues\",\n    card(\n      card_header(\n        h2(\"Colour Generator\"),\n      ),\n      layout_sidebar(\n        sidebar(\n          numericInput(\"in_n\", \"Number of colours\", value = 15),\n          sliderInput(\"in_hue\", \"Hue\", min = 0, max = 360, value = c(0, 360)),\n          sliderInput(\"in_chr\", \"Chroma\", min = 0, max = 180, value = c(0, 180)),\n          sliderInput(\"in_lig\", \"Lightness\", min = 0, max = 100, value = c(0, 100)),\n        ),\n        textOutput(\"out_text\")\n      ),\n      card_footer(\n        div(\"Built on \", a(\"hues package\", href = \"https://github.com/johnbaums/hues\"))\n      )\n    )\n  ),\n  server = function(input, output) {\n  }\n)\n```\n:::\n\n\n![](assets/hues-2.png)\n\nNow, we add content into the server part. The inputs are passed to the `get_colours()` reactive function. This function is run inside the `renderText()` function which outputs the colors as hex values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(hues)\nlibrary(bslib)\n\nshinyApp(\n  ui = page_fixed(\n    title = \"Hues\",\n    card(\n      card_header(\n        h2(\"Colour Generator\"),\n      ),\n      layout_sidebar(\n        sidebar(\n          numericInput(\"in_n\", \"Number of colours\", value = 15),\n          sliderInput(\"in_hue\", \"Hue\", min = 0, max = 360, value = c(0, 360)),\n          sliderInput(\"in_chr\", \"Chroma\", min = 0, max = 180, value = c(0, 180)),\n          sliderInput(\"in_lig\", \"Lightness\", min = 0, max = 100, value = c(0, 100)),\n        ),\n        textOutput(\"out_text\")\n      ),\n      card_footer(\n        div(\"Built on \", a(\"hues package\", href = \"https://github.com/johnbaums/hues\"))\n      )\n    )\n  ),\n  server = function(input, output) {\n    get_colours <- reactive({\n        hues::iwanthue(\n            n = input$in_n,\n            hmin = min(input$in_hue),\n            hmax = max(input$in_hue),\n            cmin = min(input$in_chr),\n            cmax = max(input$in_chr),\n            lmin = min(input$in_lig),\n            lmax = max(input$in_lig)\n        )\n    })\n\n    output$out_text <- renderText({\n        cols <- get_colours()\n        paste(cols, collapse = \", \")\n    })\n  }\n)\n```\n:::\n\n\n![](assets/hues-3.png)\n\nThe app will now generate colors as hex values, but we can't see the colors. It would be nice to visualise the colors. One option would be to create a plot which is generating an image. An alternative  lightweight option is to create div elements with the generated colors. For that we add an `htmlOutput()` element and a new `renderText()` function to the server part.\n\nThis function is creating a span element for each color. These spans are organised inside a div. The div and spans have a parent-child relationship. The span elements are laid out in a grid manner using some custom CSS. The custom CSS is added to the head of the app. We have also added a bit of CSS to add some space above the app so it doesn't touch the top.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(hues)\nlibrary(bslib)\n\nshinyApp(\n    ui = page_fixed(\n      class = \"app-container\",\n      tags$head(tags$style(HTML(\"\n      .app-container {\n          margin-top: 1em;\n      }\n\n      .grid-parent {\n          display: grid;\n          gap: 5px;\n          grid-template-columns: repeat(auto-fit, minmax(40px, 40px));\n      }\n\n      .grid-child {\n          height: 40px;\n          width: 40px;\n      }\n    \"))),\n        title = \"Hues\",\n        card(\n            card_header(\n                h2(\"Colour Generator\"),\n            ),\n            layout_sidebar(\n                sidebar(\n                    numericInput(\"in_n\", \"Number of colours\", value = 15),\n                    sliderInput(\"in_hue\", \"Hue\", min = 0, max = 360, value = c(0, 360)),\n                    sliderInput(\"in_chr\", \"Chroma\", min = 0, max = 180, value = c(0, 180)),\n                    sliderInput(\"in_lig\", \"Lightness\", min = 0, max = 100, value = c(0, 100)),\n                ),\n                htmlOutput(\"out_display\"),\n                hr(),\n                textOutput(\"out_text\")\n            ),\n            card_footer(\n                div(\"Built on \", a(\"hues package\", href = \"https://github.com/johnbaums/hues\"))\n            )\n        )\n    ),\n    server = function(input, output) {\n        get_colours <- reactive({\n            hues::iwanthue(\n                n = input$in_n,\n                hmin = min(input$in_hue),\n                hmax = max(input$in_hue),\n                cmin = min(input$in_chr),\n                cmax = max(input$in_chr),\n                lmin = min(input$in_lig),\n                lmax = max(input$in_lig)\n            )\n        })\n\n        output$out_display <- renderText({\n            cols <- get_colours()\n            paste(\"<div class='grid-parent'>\", paste(\"<span class='grid-child' style='background-color:\", cols, \";'>  </span>\", collapse = \"\"), \"</div>\", sep = \"\", collapse = \"\")\n        })\n\n        output$out_text <- renderText({\n            cols <- get_colours()\n            paste(cols, collapse = \", \")\n        })\n    }\n)\n```\n:::\n\n\n![](assets/hues-4.png)\n\n## RNA-Seq power\n\nRun power analysis for an RNA-Seq experiment.\n\n**Topics covered**\n\n-   UI layout using pre-defined function (pageWithSidebar)\n-   Input and output widgets and reactivity\n-   Conditional widgets based on user input\n-   Validating inputs and custom error messages\n-   Custom theme\n\nThe following R packages are required for this app: `c(shiny, shinythemes)`. In addition, install **RNASeqPower** from Bioconductor. `BiocManager::install('RNASeqPower')`.\n\nBelow is a preview of the complete app.\n\n![](assets/rnaseq-power-preview.png)\n\n### RNASeqPower\n\nThe R package **RNASeqPower** helps users to perform a power analysis before running an RNA-Seq experiment. It helps you to estimate, for example, the number of samples required to detect a certain level of significance. The idea of this shiny app is to create a GUI for the RNASeqPower package.\n\nSo we first need to understand how RNASeqPower works. For a complete understanding, check out [RNASeqPower](https://bioconductor.org/packages/release/bioc/html/RNASeqPower.html). For our purpose, we will take a brief look at how it works. We only need to use one function `rnapower()`. Check out `?RNASeqPower::rnapower`.\n\nSo, let's say we want to find out how many samples are required per group. We have some known input parameters. Let's say the sequencing depth is 50 (`depth=50`), coefficient of variation is 0.6 (`cv=0.6`), effect size is 1.5 fold change (`effect=1.5`), significance cut-off is 0.05 (`alpha=0.05`) and lastly power of the test is 0.8 (`power=0.8`). The parameter we want to compute is the number of samples (`n`), therefore it is not specified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(RNASeqPower)\nRNASeqPower::rnapower(depth=1000,cv=0.6,effect=2,alpha=0.05,power=0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 11.79489\n```\n:::\n:::\n\n\nAnd we get the number of samples required given these input conditions.\n\nSimilarly, we can estimate any of the other parameters (except `depth`). We can try another example where we solve for power. What would the power be for a study with 12 samples per group, to detect a 2-fold change, given deep (50x) coverage?\n\n\n::: {.cell}\n\n```{.r .cell-code}\nrnapower(depth=50, n=12, cv=0.6, effect=2, alpha=.05)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 0.7864965\n```\n:::\n:::\n\n\nAnd the function has returned the power.\n\nNow the idea is to create a web application take these input parameters from the user through input widgets.\n\n### Scaffolding\n\nLet's build the basic scaffolding for our app including the input widgets. Let's assume we are estimating number of samples.\n\nWe use a sidebar layout. The input controls go on the sidebar panel and the output goes on the main panel. So we need 5 numeric inputs. We can set some default values as well as reasonable min and max values and steps to increase or decrease. The output will be verbatim text, so we use `verbatimTextOutput()` widget.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1),\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n  },\n  options=list(height=\"500px\")\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-34-1.png){width=768}\n:::\n:::\n\n\nThe app should visually look close to our final end result. Check that the widgets work.\n\nThe next step is to wire up the inputs to the `rnapower()` function and return the result to the output text field.\n\n{{< fa clipboard-list >}} Try to see if you can get this to work.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(RNASeqPower)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1),\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    output$out_pa <- renderPrint({\n      rnapower(depth=input$in_pa_depth, cv=input$in_pa_cv, \n               effect=input$in_pa_effect, alpha=input$in_pa_alpha,\n               power=input$in_pa_power)\n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-35-1.png){width=768}\n:::\n:::\n\n\nVerify that the inputs and outputs work. One can stop at this point if you only need to compute number of samples. But, we will continue to enhance the app to be able to compute any of the other parameters.\n\n### Conditional UI\n\nThe function can estimate not only **sample size**, but **cv**, **effect**, **alpha** or **power**. We should let the user choose what they want to compute. So, we need a selection input widget to enable selection. And the input fields must change depending on the user's selected choice. The `rnapower()` function must also use a different set of parameters depending on the selection choice. For conditional logic, you can chain `if else` statements or use `switch()`.\n\n{{< fa clipboard-list >}} Try to add a selection based conditional UI. `?selectInput()`, `?uiOutput()`, `?renderUI()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(RNASeqPower)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          selectInput(\"in_pa_est\",\"Variable to estimate\",choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"),selected=1,multiple=FALSE),\n          uiOutput(\"ui_pa\")\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    \n    output$ui_pa <- renderUI({\n      switch(input$in_pa_est,\n      \"n\"=div(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1)\n        ),\n      \"cv\"=div(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_n\",\"Sample size\",value=12,min=3,max=1000,step=1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1)\n        ),\n      \"effect\"=div(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_n\",\"Sample size\",value=12,min=3,max=1000,step=1),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1)\n        ),\n      \"alpha\"=div(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_n\",\"Sample size\",value=12,min=3,max=1000,step=1),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_power\",\"Power\",value=0.8,min=0,max=1,step=0.1)\n        ),\n      \"power\"=div(\n          numericInput(\"in_pa_depth\",\"Sequencing depth\",value=100,min=1,max=1000,step=5),\n          numericInput(\"in_pa_n\",\"Sample size\",value=12,min=3,max=1000,step=1),\n          numericInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4,min=0,max=1,step=0.1),\n          numericInput(\"in_pa_effect\",\"Effect\",value=2,min=0,max=10,step=0.1),\n          numericInput(\"in_pa_alpha\",\"Alpha\",value=0.05,min=0.01,max=0.1,step=0.01)\n        )\n      )\n    })\n    \n    output$out_pa <- renderPrint({\n      \n      switch(input$in_pa_est,\n        \"n\"=rnapower(depth=input$in_pa_depth, cv=input$in_pa_cv, \n               effect=input$in_pa_effect, alpha=input$in_pa_alpha,\n               power=input$in_pa_power),\n        \"cv\"=rnapower(depth=input$in_pa_depth, n=input$in_pa_n,\n               effect=input$in_pa_effect, alpha=input$in_pa_alpha,\n               power=input$in_pa_power),\n        \"effect\"=rnapower(depth=input$in_pa_depth, cv=input$in_pa_cv, \n               n=input$in_pa_n, alpha=input$in_pa_alpha,\n               power=input$in_pa_power),\n        \"alpha\"=rnapower(depth=input$in_pa_depth, cv=input$in_pa_cv, \n               effect=input$in_pa_effect, n=input$in_pa_n,\n               power=input$in_pa_power),\n        \"power\"=rnapower(depth=input$in_pa_depth, cv=input$in_pa_cv, \n               effect=input$in_pa_effect, alpha=input$in_pa_alpha,\n               n=input$in_pa_n),\n      )\n      \n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-36-1.png){width=768}\n:::\n:::\n\n\nLet's summarize what we have done. In the **ui** part, instead of directly including the `rnapower()` input variable in the `sidebarPanel()`, we have added a selection input and a conditional UI output. The content inside the output UI depends on the selection made by the user.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nselectInput(\"in_pa_est\", \"Variable to estimate\", choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"), selected=1, multiple=FALSE),\nuiOutput(\"ui_pa\")\n```\n:::\n\n\nNow to the server part where we make this all work. All conditional UI elements are inside `renderUI({})` and we use a conditional logic inside it. And since we are returning multiple input widgets, they are all wrapped inside a `div()` container.\n\n\n::: {.cell}\n\n```{.r .cell-code}\noutput$ui_pa <- renderUI({\n  switch(input$in_pa_est,\n      \"n\"=div(),\n      \"cv\"=div()\n  )\n})\n```\n:::\n\n\nIn the `renderPrint({})` function, we use a similar idea. `rnapower()` is calculated conditionally based on the user selection.\n\n### Multiple numeric input\n\nAnother feature of the `rnapower()` function that we have not discussed so far is that all the input arguments can take more than one number as input. Or in other words, instead of a single number, it can take a vector of number. For example;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRNASeqPower::rnapower(depth=c(50,100),cv=0.6,effect=1.5,alpha=0.05,power=0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      50      100 \n36.28393 35.32909 \n```\n:::\n:::\n\n\nAnd it expands the results in various ways.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nRNASeqPower::rnapower(depth=50,cv=0.6,effect=c(1.5,2,3),alpha=0.05,power=0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n      1.5         2         3 \n36.283928 12.415675  4.942337 \n```\n:::\n:::\n\n::: {.cell}\n\n```{.r .cell-code}\nRNASeqPower::rnapower(depth=50,cv=c(0.4,0.6),effect=c(1.5,2,3),alpha=0.05,power=0.8)\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         1.5         2        3\n0.4 17.18712  5.881109 2.341107\n0.6 36.28393 12.415675 4.942337\n```\n:::\n:::\n\n\nThe output expands in a bit unpredictable manner and this is the reason why our output widget type is set to `verbatimTextOutput({})`. Otherwise, we could have formatted it to perhaps, a neater table.\n\n<i class='fa fa-comment'></i> How do we incorporate this into our app interface? Ponder over this and try to come up with solutions.\n\nOne way to do it is to accept comma separated values from the user. And then parse that into a vector of numbers. For example;\n\n\n::: {.cell}\n\n```{.r .cell-code}\nx <- \"2.5,6\"\nas.numeric(unlist(strsplit(gsub(\" \",\"\",x),\",\")))\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n[1] 2.5 6.0\n```\n:::\n:::\n\n\nBlank space are removed, the string is split by comma into a list of strings, the list is converted to a vector and the strings are coerced to numbers.\n\n{{< fa clipboard-list >}} Update the app such that all numeric inputs are replaced by text inputs and the server logic is able to parse the strings into numbers.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(RNASeqPower)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          selectInput(\"in_pa_est\",\"Variable to estimate\",choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"),selected=1,multiple=FALSE),\n          uiOutput(\"ui_pa\")\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    \n    output$ui_pa <- renderUI({\n      switch(input$in_pa_est,\n      \"n\"=div(\n          textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n          textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n          textInput(\"in_pa_effect\",\"Effect\",value=2),\n          textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n          textInput(\"in_pa_power\",\"Power\",value=0.8)\n        ),\n      \"cv\"=div(\n          textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n          textInput(\"in_pa_n\",\"Sample size\",value=12),\n          textInput(\"in_pa_effect\",\"Effect\",value=2),\n          textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n          textInput(\"in_pa_power\",\"Power\",value=0.8)\n        ),\n      \"effect\"=div(\n          textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n          textInput(\"in_pa_n\",\"Sample size\",value=12),\n          textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n          textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n          textInput(\"in_pa_power\",\"Power\",value=0.8)\n        ),\n      \"alpha\"=div(\n          textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n          textInput(\"in_pa_n\",\"Sample size\",value=12),\n          textInput(\"in_pa_cv\",\"Coefficient of variation\"),\n          textInput(\"in_pa_effect\",\"Effect\",value=2),\n          textInput(\"in_pa_power\",\"Power\",value=0.8)\n        ),\n      \"power\"=div(\n          textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n          textInput(\"in_pa_n\",\"Sample size\",value=12),\n          textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n          textInput(\"in_pa_effect\",\"Effect\",value=2),\n          textInput(\"in_pa_alpha\",\"Alpha\",value=0.05)\n        )\n      )\n    })\n    \n    output$out_pa <- renderPrint({\n      \n      switch(input$in_pa_est,\n        \"n\"={\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n          rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, power=power)\n          },\n        \"cv\"={\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))\n          effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n          rnapower(depth=depth, n=n, effect=effect, alpha=alpha, power=power)\n        },\n        \"effect\"={\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))\n          cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n          rnapower(depth=depth, cv=cv, n=n, alpha=alpha, power=power)\n        },\n        \"alpha\"={\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))\n          cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n          rnapower(depth=depth, cv=cv, effect=effect, n=n, power=power)\n        },\n        \"power\"={\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))\n          cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, n=n)\n        },\n      )\n      \n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-43-1.png){width=768}\n:::\n:::\n\n\nTo summarize our changes, in the ui part, all `numericInput()` has been changed to `textInput()` and in the process we lost the number specific input limits such as min, max, step size etc. In the server part, incoming strings are parsed and split into a vector of numbers, saved to a variable and passed to the `rnapower()` function. Ensure that the app works without errors and we can progress further.\n\n### Code cleaning\n\nIt is good practice to check whether the current code can be cleaned-up/polished or reduced. In this example, **depth** is always needed and could be moved out of the conditional block. Only one variable changes based on user input, but all 5 variables are repeated in each conditional block. There is room for improvement there.\n\n{{< fa clipboard-list >}} Try to figure out how the code can be reorganized and simplified.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(RNASeqPower)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          selectInput(\"in_pa_est\",\"Variable to estimate\",choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"),selected=1,multiple=FALSE),\n          uiOutput(\"ui_pa\")\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    \n    output$ui_pa <- renderUI({\n      div(\n        textInput(\"in_pa_depth\",\"Sequencing depth\",value=4),\n        if(input$in_pa_est != \"n\")  textInput(\"in_pa_n\",\"Sample size\",value=100),\n        if(input$in_pa_est != \"cv\")  textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n        if(input$in_pa_est != \"effect\")  textInput(\"in_pa_effect\",\"Effect\",value=2),\n        if(input$in_pa_est != \"alpha\")  textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n        if(input$in_pa_est != \"power\")  textInput(\"in_pa_power\",\"Power\",value=0.8)\n      )\n    })\n    \n    output$out_pa <- renderPrint({\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          if(input$in_pa_est != \"n\")  n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))\n          if(input$in_pa_est != \"cv\") cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          if(input$in_pa_est != \"effect\") effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          if(input$in_pa_est != \"alpha\")  alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          if(input$in_pa_est != \"power\")  power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n            \n      switch(input$in_pa_est,\n        \"n\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, power=power),\n        \"cv\"=rnapower(depth=depth, n=n, effect=effect, alpha=alpha, power=power),\n        \"effect\"=rnapower(depth=depth, cv=cv, n=n, alpha=alpha, power=power),\n        \"alpha\"=rnapower(depth=depth, cv=cv, effect=effect, n=n, power=power),\n        \"power\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, n=n)\n      )\n      \n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-44-1.png){width=768}\n:::\n:::\n\n\nUI and server blocks have been considerably reduced in length by removing redundant code.\n\n### Input validation\n\nWhen we changed numeric inputs to character, we lost the input limits and numeric validation. Regardless of what input you enter, the app tries to proceed with the calculation.\n\n{{< fa clipboard-list >}} Try entering some unreasonable inputs and see what happens. Try entering random strings, or huge integers for **alpha** etc.\n\nWe can bring back input validation manually using `validate()` functions. This can be used to check if the input conforms to some expected range of values and if not, return a message to the user.\n\nHere are the limits we want to set:\n\n-   `depth`: A numeric\n-   `n`: A numeric\n-   `cv`: A numeric\n-   `effect`: A numeric\n-   `alpha`: A numeric between 0 and 1 excluding 0 and 1\n-   `power`: A numeric between 0 and 1 excluding 0 and 1\n\n{{< fa clipboard-list >}} Try to figure out how to add input validation. `?shiny::validate()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(RNASeqPower)\n\n# returns a message if condition is true\nfn_validate <- function(input,message) if(input) print(message)\n\nshinyApp(\n  ui=fluidPage(\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n          selectInput(\"in_pa_est\",\"Variable to estimate\",choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"),selected=1,multiple=FALSE),\n          uiOutput(\"ui_pa\")\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    \n    output$ui_pa <- renderUI({\n      div(\n        textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n        if(input$in_pa_est != \"n\")  textInput(\"in_pa_n\",\"Sample size\",value=12),\n        if(input$in_pa_est != \"cv\")  textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n        if(input$in_pa_est != \"effect\")  textInput(\"in_pa_effect\",\"Effect\",value=2),\n        if(input$in_pa_est != \"alpha\")  textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n        if(input$in_pa_est != \"power\")  textInput(\"in_pa_power\",\"Power\",value=0.8)\n      )\n    })\n    \n    output$out_pa <- renderPrint({\n          depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n          validate(fn_validate(any(is.na(depth)),\"Sequencing depth must be a numeric.\"))\n          \n          if(input$in_pa_est != \"n\") {\n            n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))       \n            validate(fn_validate(any(is.na(n)),\"Sample size must be a numeric.\"))\n          }\n          \n          if(input$in_pa_est != \"cv\") {\n            cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n            validate(fn_validate(any(is.na(cv)),\"Coefficient of variation must be a numeric.\"))\n          }\n          \n          if(input$in_pa_est != \"effect\") {\n            effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n            validate(fn_validate(any(is.na(effect)),\"Effect must be a numeric.\"))\n          }\n          \n          if(input$in_pa_est != \"alpha\")  {\n            alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n            validate(fn_validate(any(is.na(alpha)),\"Alpha must be a numeric.\"))\n            validate(fn_validate(any(alpha>=1|alpha<=0),\"Alpha must be a numeric between 0 and 1.\"))\n          }\n          \n          if(input$in_pa_est != \"power\")  {\n            power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n            validate(fn_validate(any(is.na(power)),\"Power must be a numeric.\"))\n            validate(fn_validate(any(power>=1|power<=0),\"Power must be a numeric between 0 and 1.\"))\n          }\n            \n      switch(input$in_pa_est,\n        \"n\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, power=power),\n        \"cv\"=rnapower(depth=depth, n=n, effect=effect, alpha=alpha, power=power),\n        \"effect\"=rnapower(depth=depth, cv=cv, n=n, alpha=alpha, power=power),\n        \"alpha\"=rnapower(depth=depth, cv=cv, effect=effect, n=n, power=power),\n        \"power\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, n=n)\n      )\n      \n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-45-1.png){width=768}\n:::\n:::\n\n\nWe have added `validate()` to all incoming text to ensure that user input is within reasonable limits.\n\n{{< fa clipboard-list >}} Test that the validation works by inputting unreasonable inputs such as alphabets, symbols etc into the input fields.\n\n### Theme\n\nThis part is purely cosmetic. We can add a custom theme from R package `shinythemes` to make our app stand out from the default. The theme is added as an argument to `fluidPage()` like so `fluidPage(theme = shinytheme(\"spacelab\"))`.\n\n{{< fa clipboard-list >}} Try changing the theme and pick one that you like. Check out `?shinythemes`. The themes can be visualized on [Bootswatch](https://bootswatch.com/).\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(shiny)\nlibrary(shinythemes)\nlibrary(RNASeqPower)\n\n# returns a message if condition is true\nfn_validate <- function(input,message) if(input) print(message)\n\nshinyApp(\n  ui=fluidPage(\n    theme=shinytheme(\"spacelab\"),\n    titlePanel(\"RNA-Seq | Power analysis\"),\n    sidebarLayout(\n      sidebarPanel(\n        selectInput(\"in_pa_est\",\"Variable to estimate\",choices=c(\"n\",\"cv\",\"effect\",\"alpha\",\"power\"),selected=1,multiple=FALSE),\n        uiOutput(\"ui_pa\")\n      ),\n      mainPanel(\n        verbatimTextOutput(\"out_pa\")\n      )\n    )\n  ),\n  server=function(input,output){\n    \n    output$ui_pa <- renderUI({\n      div(\n        textInput(\"in_pa_depth\",\"Sequencing depth\",value=100),\n        if(input$in_pa_est != \"n\")  textInput(\"in_pa_n\",\"Sample size\",value=12),\n        if(input$in_pa_est != \"cv\")  textInput(\"in_pa_cv\",\"Coefficient of variation\",value=0.4),\n        if(input$in_pa_est != \"effect\")  textInput(\"in_pa_effect\",\"Effect\",value=2),\n        if(input$in_pa_est != \"alpha\")  textInput(\"in_pa_alpha\",\"Alpha\",value=0.05),\n        if(input$in_pa_est != \"power\")  textInput(\"in_pa_power\",\"Power\",value=0.8)\n      )\n    })\n    \n    output$out_pa <- renderPrint({\n      \n        depth <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_depth),\",\")))\n        validate(fn_validate(any(is.na(depth)),\"Sequencing depth must be a numeric.\"))\n        \n        if(input$in_pa_est != \"n\") {\n          n <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_n),\",\")))       \n          validate(fn_validate(any(is.na(n)),\"Sample size must be a numeric.\"))\n        }\n        \n        if(input$in_pa_est != \"cv\") {\n          cv <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_cv),\",\")))\n          validate(fn_validate(any(is.na(cv)),\"Coefficient of variation must be a numeric.\"))\n        }\n        \n        if(input$in_pa_est != \"effect\") {\n          effect <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_effect),\",\")))\n          validate(fn_validate(any(is.na(effect)),\"Effect must be a numeric.\"))\n        }\n        \n        if(input$in_pa_est != \"alpha\")  {\n          alpha <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_alpha),\",\")))\n          validate(fn_validate(any(is.na(alpha)),\"Alpha must be a numeric.\"))\n          validate(fn_validate(any(alpha>=1|alpha<=0),\"Alpha must be a numeric between 0 and 1.\"))\n        }\n        \n        if(input$in_pa_est != \"power\")  {\n          power <- as.numeric(unlist(strsplit(gsub(\" \",\"\",input$in_pa_power),\",\")))\n          validate(fn_validate(any(is.na(power)),\"Power must be a numeric.\"))\n          validate(fn_validate(any(power>=1|power<=0),\"Power must be a numeric between 0 and 1.\"))\n        }\n        \n        switch(input$in_pa_est,\n               \"n\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, power=power),\n               \"cv\"=rnapower(depth=depth, n=n, effect=effect, alpha=alpha, power=power),\n               \"effect\"=rnapower(depth=depth, cv=cv, n=n, alpha=alpha, power=power),\n               \"alpha\"=rnapower(depth=depth, cv=cv, effect=effect, n=n, power=power),\n               \"power\"=rnapower(depth=depth, cv=cv, effect=effect, alpha=alpha, n=n)\n        )\n    })\n  }\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-46-1.png){width=768}\n:::\n:::\n\n\nThis is the completed app.\n\n### Deployment\n\nYou do not necessarily need to do this section. This is just so you know.\n\nThe app is now ready to be deployed. If you have an account on [shinyapps.io](https://www.shinyapps.io/), you can quickly deploy this app to your account using the R package `rsconnect`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nlibrary(rsconnect)\nrsconnect::setAccountInfo(name=\"username\", token=\"KJHF853HG6G59C2F4J7B6\", secret=\"jhHD7%jdg)62F67G/\")\ndeployApp(appName=\"my-awesome-app\",appDir=\".\")\n```\n:::\n\n\nThe packages used are automatically detected and are installed on to the instance. If Bioconductor packages give an error during deployment, the repositories need to be explicitly set on your system.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nsetRepositories(c(1,2),graphics=FALSE)\n```\n:::\n\n\nThis completes this app tutorial. Hope you have enjoyed this build and learned something interesting along the way. There are few more example apps below, but that is optional.\n\n## Calendar app\n\nA shiny app to create a calendar planner plot.\n\n**Topics covered**\n\n-   UI layout using pre-defined function (pageWithSidebar)\n-   Input and output widgets and reactivity\n-   Use of date-time\n-   Customised ggplot\n-   Download image files\n-   Update inputs using observe\n-   Validating inputs with custom error messages\n\nThe following R packages will be required for this app: `ggplot2`, `shiny`, `colourpicker`.\n\nBelow is a preview of the finished app.\n\n![](assets/calendar-preview.png)\n\nThe idea of this app is to create and display a calendar styled planner. Below is a preview of the expected output.\n\n![](assets/calendar_plot.png)\n\nThe image is a plot created in ggplot. X axis showing week numbers, y axis showing weekdays, facet titles showing months and dates are colored by categories. We can split this into two parts. The first part is preparing the code for the core task at hand (ie; generating the plot) and the second part is creating a graphical user interface around it using shiny apps to enable the user to input values and adjust dates, categories, plot parameters etc.\n\n### Creating the plot\n\nThe first step is to figure out how to create this plot in ggplot. The data will be contained in a data.frame. The data.frame is created based on start and end dates.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nstart_date <- as.Date(\"2023-06-01\")\nend_date <- as.Date(\"2023-07-05\")\ndfr <- data.frame(date=seq(start_date,end_date,by=1))\nhead(dfr)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       |\n|:----------|\n|2023-06-01 |\n|2023-06-02 |\n|2023-06-03 |\n|2023-06-04 |\n|2023-06-05 |\n|2023-06-06 |\n\n</div>\n:::\n:::\n\n\nWe can add some code to get specific information from these dates such as the day, week, month and numeric date. Finally we\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfr$day <- factor(strftime(dfr$date,format=\"%a\"),levels=rev(c(\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\")))\ndfr$week <- factor(strftime(dfr$date,format=\"%V\"))\ndfr$month <- strftime(dfr$date,format=\"%B\")\ndfr$month <- factor(dfr$month,levels=unique(dfr$month))\ndfr$ddate <- factor(strftime(dfr$date,format=\"%d\"))\nhead(dfr)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       |day |week |month |ddate |\n|:----------|:---|:----|:-----|:-----|\n|2023-06-01 |Thu |22   |June  |01    |\n|2023-06-02 |Fri |22   |June  |02    |\n|2023-06-03 |Sat |22   |June  |03    |\n|2023-06-04 |Sun |22   |June  |04    |\n|2023-06-05 |Mon |23   |June  |05    |\n|2023-06-06 |Tue |23   |June  |06    |\n\n</div>\n:::\n:::\n\n\nFinally, we add a column called track which will hold the categorical information for colouring dates by activity.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfr$track <- \"Available\"\ndfr$track[dfr$day==\"Sat\"|dfr$day==\"Sun\"] <- \"Weekend\"\nhead(dfr)\n```\n\n::: {.cell-output-display}\n<div class=\"kable-table\">\n\n|date       |day |week |month |ddate |track     |\n|:----------|:---|:----|:-----|:-----|:---------|\n|2023-06-01 |Thu |22   |June  |01    |Available |\n|2023-06-02 |Fri |22   |June  |02    |Available |\n|2023-06-03 |Sat |22   |June  |03    |Weekend   |\n|2023-06-04 |Sun |22   |June  |04    |Weekend   |\n|2023-06-05 |Mon |23   |June  |05    |Available |\n|2023-06-06 |Tue |23   |June  |06    |Available |\n\n</div>\n:::\n:::\n\n\nThis is enough information to plot.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nggplot(dfr,aes(x=week,y=day))+\n      geom_tile(aes(fill=track))+\n      geom_text(aes(label=ddate))+\n      facet_grid(~month,scales=\"free\",space=\"free\")+\n      theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-52-1.png){width=672}\n:::\n:::\n\n\nWe can add more activities to the track column. Or in other words, I refer to it as adding more tracks.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ndfr$track[dfr$date>=as.Date(\"2023-06-13\") & dfr$date<=as.Date(\"2023-06-17\")] <- \"RaukR\"\ndfr$track[dfr$date==as.Date(\"2023-06-24\")] <- \"Midsummer\"\n\nggplot(dfr,aes(x=week,y=day))+\n      geom_tile(aes(fill=track))+\n      geom_text(aes(label=ddate))+\n      facet_grid(~month,scales=\"free\",space=\"free\")+\n      theme_bw()\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-53-1.png){width=672}\n:::\n:::\n\n\nNow, we can customize the plot as you prefer. I am modifying the axes labels, changing colors and removing most of the plot elements.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nall_cols <- c(\"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\")\n  \nggplot(dfr,aes(x=week,y=day))+\n      geom_tile(aes(fill=track))+\n      geom_text(aes(label=ddate))+\n      scale_fill_manual(values=all_cols)+\n      facet_grid(~month,scales=\"free\",space=\"free\")+\n      labs(x=\"Week\",y=\"\")+\n      theme_bw(base_size=14)+\n      theme(legend.title=element_blank(),\n            panel.grid=element_blank(),\n            panel.border=element_blank(),\n            axis.ticks=element_blank(),\n            axis.title=element_text(colour=\"grey30\"),\n            strip.background=element_blank(),\n            legend.key.size=unit(0.3,\"cm\"),\n            legend.spacing.x=unit(0.2,\"cm\"))\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-54-1.png){width=672}\n:::\n:::\n\n\nOur plot is now ready and we have the code to create this plot. The next step is to build a shiny app around it.\n\n### Building the app\n\n#### Layout\n\nWe need to first have a plan for the app page, which UI elements to include and how they will be laid out and structured. My plan is as shown in the preview image.\n\n![](assets/calendar-preview.png)\n\nThere is a horizontal top bar for the title and two columns below. The left column will contain the input widgets and control. The right column will contain the plot output. Since, this is a commonly used layout, it is available as a predefined function in shiny called `pageWithSidebar()`. It takes three arguments `headerPanel`, `sidebarPanel` and `mainPanel` which is self explanatory.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  pageWithSidebar(\n    headerPanel(),\n    sidebarPanel(),\n    mainPanel())\n  ),\nserver=function(input,output){}\n)\n```\n:::\n\n\n#### UI\n\nThen we fill in the panels with widgets and contents.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nshinyApp(\nui=fluidPage(\n  pageWithSidebar(\n    headerPanel(title=\"Calendar Planner\",windowTitle=\"Calendar Planner\"),\n    sidebarPanel(\n      h3(\"Duration\"),\n      fluidRow(\n          column(6,\n              dateInput(\"in_duration_date_start\",\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(6,\n              dateInput(\"in_duration_date_end\",\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          )\n      )\n    ),\n    mainPanel())\n  ),\nserver=function(input,output){},\n  options=list(height=\"400px\")\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-56-1.png){width=768}\n:::\n:::\n\n\nWe have defined a part of the side bar panel with a title **Duration**. `fluidRow()` is an html tag used to create rows. Above, in the side bar panel, a row is defined and two columns are defined inside. Each column is filled with date input widgets for start and end dates. We use the columns here to place date input widgets side by side. To place widgets one below the other, the columns can simply be removed. The default value for the start date is set to current date and the end date is set to current date + 30 days.\n\nNow we add more sections to the side bar panel, namely track input variables and plot settings variables. We also added custom colors. Custom colors can be selected using the input widget `colourpicker::colourInput()`.\n\n\n::: {.cell}\n\n```{.r .cell-code}\ncols <- toupper(c(\n  \"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#FDBF6F\",\"#A6CEE3\",\n  \"#56B4E9\",\"#B2DF8A\",\"#FB9A99\",\"#CAB2D6\",\"#A9C4E2\",\"#79C360\",\"#FDB762\",\"#9471B4\",\n  \"#A4A4A4\",\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\n  \"#fddaec\",\"#f2f2f2\",\"#8dd3c7\",\"#d9d9d9\"))\n  \nshinyApp(\nui=fluidPage(\n  pageWithSidebar(\n    headerPanel(title=\"Calendar Planner\",windowTitle=\"Calendar Planner\"),\n    sidebarPanel(\n      h3(\"Duration\"),\n      fluidRow(\n          column(6,\n              dateInput(\"in_duration_date_start\",\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(6,\n              dateInput(\"in_duration_date_end\",\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          )\n      ),\n      h3(\"Tracks\"),\n      fluidRow(\n          column(3,\n              textInput(\"in_track_name_1\",label=\"Name\",value=\"Vacation\",placeholder=\"Vacation\")\n          ),\n          column(3,\n              dateInput(\"in_track_date_start_1\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,\n              dateInput(\"in_track_date_end_1\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,\n              colourpicker::colourInput(\"in_track_colour_1\",label=\"Colour\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[1])\n          )\n      ),\n      fluidRow(\n          column(3,\n              textInput(\"in_track_name_2\",label=\"Name\",value=\"Offline\",placeholder=\"Offline\")\n          ),\n          column(3,\n              dateInput(\"in_track_date_start_2\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,\n              dateInput(\"in_track_date_end_2\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,\n              colourpicker::colourInput(\"in_track_colour_2\",label=\"Colour\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[2])\n          )\n      ),\n      fluidRow(\n          column(6,\n              colourpicker::colourInput(\"in_track_colour_available\",label=\"Track colour (Available)\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[length(cols)-1])\n          ),\n          column(6,\n              colourpicker::colourInput(\"in_track_colour_weekend\",label=\"Track colour (Weekend)\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[length(cols)])\n          )\n      ),\n      tags$br(),\n      h3(\"Settings\"),\n      selectInput(\"in_legend_position\",label=\"Legend position\",\n                  choices=c(\"top\",\"right\",\"left\",\"bottom\"),selected=\"right\",multiple=F),\n      fluidRow(\n          column(6,\n              selectInput(\"in_legend_justification\",label=\"Legend justification\",\n                          choices=c(\"left\",\"right\"),selected=\"right\",multiple=F)\n          ),\n          column(6,\n              selectInput(\"in_legend_direction\",label=\"Legend direction\",\n                          choices=c(\"vertical\",\"horizontal\"),selected=\"vertical\",multiple=F)\n          )\n      ),\n      fluidRow(\n          column(6,\n              numericInput(\"in_themefontsize\",label=\"Theme font size\",value=8,step=0.5)\n          ),\n          column(6,\n              numericInput(\"in_datefontsize\",label=\"Date font size\",value=2.5,step=0.1)\n          )\n      ),\n      fluidRow(\n          column(6,\n              numericInput(\"in_monthfontsize\",label=\"Month font size\",value=8,step=0.5)\n          ),\n          column(6,\n              numericInput(\"in_legendfontsize\",label=\"Legend font size\",value=5,step=0.5)\n          )\n      )\n    ),\n    mainPanel(\n      plotOutput(\"out_plot\")\n    ))\n  ),\nserver=function(input,output){}\n)\n```\n\n::: {.cell-output-display}\n![](index_files/figure-html/unnamed-chunk-57-1.png){width=768}\n:::\n:::\n\n\n![](assets/calendar-2.png)\n\nThe track start and end dates are by default set to the same as that of duration start and end dates. We will adjust this later. Under the settings section, we have added a few useful plot variables to adjust sizes and spacing of plot elements. They are set to reasonable defaults. These variables will be passed on to the ggplot plotting function.\n\nWe can end with column with the download options. Input fields are height, width, resolution and file format. Last we add a button for download.\n\n\n::: {.cell}\n\n```{.r .cell-code}\nh3(\"Download\"),\nhelpText(\"Width is automatically calculated based on the number of weeks. File type is only applicable to download and does not change preview.\"),\nfluidRow(\n    column(6,\n        numericInput(\"in_height\",\"Height (cm)\",step=0.5,value=5.5)\n    ),\n    column(6,\n        numericInput(\"in_width\",\"Width (cm)\",step=0.5,value=NA)\n    )\n),\nfluidRow(\n    column(6,\n        selectInput(\"in_res\",\"Res/DPI\",choices=c(\"200\",\"300\",\"400\",\"500\"),selected=\"200\")\n    ),\n    column(6,\n        selectInput(\"in_format\",\"File type\",choices=c(\"png\",\"tiff\",\"jpeg\",\"pdf\"),selected=\"png\",multiple=FALSE,selectize=TRUE)\n    )\n),\ndownloadButton(\"btn_downloadplot\",\"Download Plot\"),\ntags$hr(),\nhelpText(\"RaukR\")\n```\n:::\n\n\nIn the main panel, we add the plot output function that will hold the output plot. We also add a slider for image preview scaling and the output image. The idea behind the preview scaling is to allow the user to increase or decrease the size of the plot in the browser without affecting the download size. The part of the UI code to add the preview slider is below:\n\n\n::: {.cell}\n\n```{.r .cell-code}\nmainPanel(\n  sliderInput(\"in_scale\",\"Image preview scale\",min=0.1,max=3,step=0.10,value=1),\n  helpText(\"Scale only controls preview here and does not affect download.\"),\n  tags$br(),\n  imageOutput(\"out_plot\")\n)\n```\n:::\n\n\nThis should now look like this. Some additional styling has been added to divs.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## load colours\ncols <- toupper(c(\n  \"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#FDBF6F\",\"#A6CEE3\",\n  \"#56B4E9\",\"#B2DF8A\",\"#FB9A99\",\"#CAB2D6\",\"#A9C4E2\",\"#79C360\",\"#FDB762\",\"#9471B4\",\n  \"#A4A4A4\",\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\n  \"#fddaec\",\"#f2f2f2\",\"#8dd3c7\",\"#d9d9d9\"))\n\nshinyApp(\n  ui=fluidPage(\n    pageWithSidebar(\n      headerPanel(title=\"Calendar Planner\",windowTitle=\"Calendar Planner\"),\n      sidebarPanel(\n        h3(\"Duration\"),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 dateInput(\"in_duration_date_start\",\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 dateInput(\"in_duration_date_end\",\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          )\n        ),\n        h3(\"Tracks\"),\n        fluidRow(\n          column(3,style=list(\"padding-right: 3px;\"),\n                 textInput(\"in_track_name_1\",label=\"Name\",value=\"Vacation\",placeholder=\"Vacation\")\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n                 dateInput(\"in_track_date_start_1\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n                 dateInput(\"in_track_date_end_1\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-left: 3px;\"),\n                 colourpicker::colourInput(\"in_track_colour_1\",label=\"Colour\",\n                                           palette=\"limited\",allowedCols=cols,value=cols[1])\n          )\n        ),\n        fluidRow(\n          column(3,style=list(\"padding-right: 3px;\"),\n                 textInput(\"in_track_name_2\",label=\"Name\",value=\"Offline\",placeholder=\"Offline\")\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n                 dateInput(\"in_track_date_start_2\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n                 dateInput(\"in_track_date_end_2\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-left: 3px;\"),\n                 colourpicker::colourInput(\"in_track_colour_2\",label=\"Colour\",\n                                           palette=\"limited\",allowedCols=cols,value=cols[2])\n          )\n        ),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 colourpicker::colourInput(\"in_track_colour_available\",label=\"Track colour (Available)\",\n                                           palette=\"limited\",allowedCols=cols,value=cols[length(cols)-1])\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 colourpicker::colourInput(\"in_track_colour_weekend\",label=\"Track colour (Weekend)\",\n                                           palette=\"limited\",allowedCols=cols,value=cols[length(cols)])\n          )\n        ),\n        tags$br(),\n        h3(\"Settings\"),\n        selectInput(\"in_legend_position\",label=\"Legend position\",\n                    choices=c(\"top\",\"right\",\"left\",\"bottom\"),selected=\"right\",multiple=F),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 selectInput(\"in_legend_justification\",label=\"Legend justification\",\n                             choices=c(\"left\",\"right\"),selected=\"right\",multiple=F)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 selectInput(\"in_legend_direction\",label=\"Legend direction\",\n                             choices=c(\"vertical\",\"horizontal\"),selected=\"vertical\",multiple=F)\n          )\n        ),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 numericInput(\"in_themefontsize\",label=\"Theme font size\",value=8,step=0.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 numericInput(\"in_datefontsize\",label=\"Date font size\",value=2.5,step=0.1)\n          )\n        ),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 numericInput(\"in_monthfontsize\",label=\"Month font size\",value=8,step=0.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 numericInput(\"in_legendfontsize\",label=\"Legend font size\",value=5,step=0.5)\n          )\n        ),\n        tags$br(),\n        h3(\"Download\"),\n        helpText(\"Width is automatically calculated based on the number of weeks. File type is only applicable to download and does not change preview.\"),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 numericInput(\"in_height\",\"Height (cm)\",step=0.5,value=5.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 numericInput(\"in_width\",\"Width (cm)\",step=0.5,value=NA)\n          )\n        ),\n        fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n                 selectInput(\"in_res\",\"Res/DPI\",choices=c(\"200\",\"300\",\"400\",\"500\"),selected=\"200\")\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n                 selectInput(\"in_format\",\"File type\",choices=c(\"png\",\"tiff\",\"jpeg\",\"pdf\"),selected=\"png\",multiple=FALSE,selectize=TRUE)\n          )\n        ),\n        downloadButton(\"btn_downloadplot\",\"Download Plot\"),\n        tags$hr(),\n        helpText(\"RaukR\")\n      ),\n      mainPanel(\n        sliderInput(\"in_scale\",\"Image preview scale\",min=0.1,max=3,step=0.10,value=1),\n        helpText(\"Scale only controls preview here and does not affect download.\"),\n        tags$br(),\n        imageOutput(\"out_plot\")\n      )\n    )\n  ),\n  server=function(input,output){}\n)\n```\n:::\n\n\n![](assets/calendar-3.png)\n\n#### Server\n\nWe can start adding content into the server function to actually enable functionality.\n\nThe server code can be organized into 5 blocks.\n\n1.  `fn_plot()`: Reactive function that generates ggplot object\n2.  out_plot: Plots the ggplot object\n3.  `fn_downloadplotname()`: Function to create download image name\n4.  `fn_downloadplot()`: Function to create and download the image\n5.  `btn_downloadplot`: Download handler that runs `fn_downloadplot` on button trigger\n6.  observe: Observer that updates input values\n\nHere is a flow diagram of how these blocks work.\n\n```         \n     1 > [2]\n     v\n3 > [4] < 5\n\n    {6}\n```\n\nThe core block 1 creates the preview plot in block 2. The download handler block 5 calls block 1 to generate the plot which is downloaded using block 4. Block 6 is standalone observer.\n\nReactive values used across multiple functions can be stored using `reactiveValues()`. These can be written to or accessed from within a reactive environment.\n\n```         \nstore <- reactiveValues(week=NULL)\n```\n\nWe have our core function `fn_plot()` (block 1). Inputs are validated and gathered from input widgets. We are using `shiny::req()` to silently check that necessary input variables are available before running through the function. We use `validate()` with `need()` to run some basic sanity checks namely that track names are not duplicated and to ensure that start-dates precede end-dates. Necessary date-time calculations are performed. The calendar plot is created and returned.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## RFN: fn_plot -----------------------------------------------------------\n## core plotting function, returns a ggplot object\n\nfn_plot <- reactive({\n\n  shiny::req(input$in_duration_date_start)\n  shiny::req(input$in_duration_date_end)\n\n  shiny::req(input$in_track_date_start_1)\n  shiny::req(input$in_track_date_end_1)\n  shiny::req(input$in_track_name_1)\n  shiny::req(input$in_track_colour_1)\n\n  shiny::req(input$in_track_date_start_2)\n  shiny::req(input$in_track_date_end_2)\n  shiny::req(input$in_track_name_2)\n  shiny::req(input$in_track_colour_2)\n\n  shiny::req(input$in_legend_position)\n  shiny::req(input$in_legend_justification)\n  shiny::req(input$in_legend_direction)\n  shiny::req(input$in_themefontsize)\n  shiny::req(input$in_datefontsize)\n  shiny::req(input$in_monthfontsize)\n  shiny::req(input$in_legendfontsize)\n\n  validate(need(input$in_track_name_1!=input$in_track_name_2,\"Duplicate track names are not allowed.\"))\n  validate(need(as.Date(input$in_duration_date_start) < as.Date(input$in_duration_date_end),\"End duration date must be later than start duration date.\"))\n\n  # prepare dates\n  dfr <- data.frame(date=seq(as.Date(input$in_duration_date_start),as.Date(input$in_duration_date_end),by=1))\n  dfr$day <- factor(strftime(dfr$date,format=\"%a\"),levels=rev(c(\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\")))\n  dfr$week <- factor(strftime(dfr$date,format=\"%V\"))\n  dfr$month <- strftime(dfr$date,format=\"%B\")\n  dfr$month <- factor(dfr$month,levels=unique(dfr$month))\n  dfr$ddate <- factor(strftime(dfr$date,format=\"%d\"))\n\n  #add tracks\n  dfr$track <- \"Available\"\n  dfr$track[dfr$day==\"Sat\" | dfr$day==\"Sun\"] <- \"Weekend\"\n\n  temp_start_date_1 <- as.Date(input$in_track_date_start_1)\n  temp_end_date_1 <- as.Date(input$in_track_date_end_1)\n  temp_track_name_1 <- input$in_track_name_1\n  temp_track_col_1 <- input$in_track_colour_1\n  validate(need(temp_start_date_1 < temp_end_date_1,\"End track duration date must be later than start track duration date.\"))\n  dfr$track[dfr$date>=temp_start_date_1 & dfr$date<=temp_end_date_1] <- temp_track_name_1\n\n  temp_start_date_2 <- as.Date(input$in_track_date_start_2)\n  temp_end_date_2 <- as.Date(input$in_track_date_end_2)\n  temp_track_name_2 <- input$in_track_name_2\n  temp_track_col_2 <- input$in_track_colour_2\n  validate(need(temp_start_date_2 < temp_end_date_2,\"End track duration date must be later than start track duration date.\"))\n  dfr$track[dfr$date>=temp_start_date_2 & dfr$date<=temp_end_date_2] <- temp_track_name_2\n\n  # create order factor\n  fc <- vector(mode=\"character\")\n  if(\"Available\" %in% unique(dfr$track)) fc <- c(fc,\"Available\")\n  fc <- c(fc,temp_track_name_1,temp_track_name_2)\n  if(\"Weekend\" %in% unique(dfr$track)) fc <- c(fc,\"Weekend\")\n  dfr$track <- factor(dfr$track,levels=fc)\n\n  # prepare colours\n  all_cols <- c(input$in_track_colour_available,temp_track_col_1,temp_track_col_2,input$in_track_colour_weekend)\n\n  # plot\n  p <- ggplot(dfr,aes(x=week,y=day))+\n    geom_tile(aes(fill=track))+\n    geom_text(aes(label=ddate),size=input$in_datefontsize)+\n    scale_fill_manual(values=all_cols)+\n    facet_grid(~month,scales=\"free\",space=\"free\")+\n    labs(x=\"Week\",y=\"\")+\n    theme_bw(base_size=input$in_themefontsize)+\n    theme(legend.title=element_blank(),\n          panel.grid=element_blank(),\n          panel.border=element_blank(),\n          axis.ticks=element_blank(),\n          axis.title=element_text(colour=\"grey30\"),\n          strip.background=element_blank(),\n          strip.text=element_text(size=input$in_monthfontsize),\n          legend.position=input$in_legend_position,\n          legend.justification=input$in_legend_justification,\n          legend.direction=input$in_legend_direction,\n          legend.text=element_text(size=input$in_legendfontsize),\n          legend.key.size=unit(0.3,\"cm\"),\n          legend.spacing.x=unit(0.2,\"cm\"))\n\n  # add number of weeks to reactive value\n  store$week <- length(levels(dfr$week))\n\n  return(p)\n})\n```\n:::\n\n\nHere is the block that generates the output image. Image dimensions and resolution is obtained from input widgets. Default width is computed based on number of weeks. This is why the number of weeks was stored as a reactive value. The plot is exported to the working directly and then displayed in the browser. The scale slider allows the plot preview to be scaled in the browser.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## OUT: out_plot ------------------------------------------------------------\n## plots figure\n\noutput$out_plot <- renderImage({\n\n  shiny::req(fn_plot())\n  shiny::req(input$in_height)\n  shiny::req(input$in_res)\n  shiny::req(input$in_scale)\n\n  height <- as.numeric(input$in_height)\n  width <- as.numeric(input$in_width)\n  res <- as.numeric(input$in_res)\n\n  if(is.na(width)) {\n    width <- (store$week*1.2)\n    if(width < 4.5) width <- 4.5\n  }\n\n  p <- fn_plot()\n  ggsave(\"calendar_plot.png\",p,height=height,width=width,units=\"cm\",dpi=res)\n\n  return(list(src=\"calendar_plot.png\",\n              contentType=\"image/png\",\n              width=round(((width*res)/2.54)*input$in_scale,0),\n              height=round(((height*res)/2.54)*input$in_scale,0),\n              alt=\"calendar_plot\"))\n}, deleteFile=TRUE)\n```\n:::\n\n\nThe `fn_downloadplotname()` function simply generates the output filename depending on the filetype extension.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n# FN: fn_downloadplotname ----------------------------------------------------\n# creates filename for download plot\n\nfn_downloadplotname <- function()\n{\n  return(paste0(\"calendar_plot.\",input$in_format))\n}\n```\n:::\n\n\nThe `fn_downloadplot()` function uses `fn_plot()` to create the image and then export the image.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## FN: fn_downloadplot -------------------------------------------------\n## function to download plot\n\nfn_downloadplot <- function(){\n  shiny::req(fn_plot())\n  shiny::req(input$in_height)\n  shiny::req(input$in_res)\n  shiny::req(input$in_scale)\n\n  height <- as.numeric(input$in_height)\n  width <- as.numeric(input$in_width)\n  res <- as.numeric(input$in_res)\n  format <- input$in_format\n\n  if(is.na(width)) width <- (store$week*1)+1\n\n  p <- fn_plot()\n  if(format==\"pdf\" | format==\"svg\"){\n    ggsave(fn_downloadplotname(),p,height=height,width=width,units=\"cm\",dpi=res)\n    #embed_fonts(fn_downloadplotname())\n  }else{\n    ggsave(fn_downloadplotname(),p,height=height,width=width,units=\"cm\",dpi=res)\n  }\n}\n```\n:::\n\n\nThe download handler then downloads the file.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## DHL: btn_downloadplot ----------------------------------------------------\n## download handler for downloading plot\n\noutput$btn_downloadplot <- downloadHandler(\n  filename=fn_downloadplotname,\n  content=function(file) {\n    fn_downloadplot()\n    file.copy(fn_downloadplotname(),file,overwrite=T)\n  }\n)\n```\n:::\n\n\nFinally, we have the observer function. The observer continuously monitors change in input widgets of interest (here start and end duration) and updates other widget values.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## OBS: tracks dates ---------------------------------------------------------\n\nobserve({\n  \n  shiny::req(input$in_duration_date_start)\n  shiny::req(input$in_duration_date_end)\n  \n  validate(need(as.Date(input$in_duration_date_start) < as.Date(input$in_duration_date_end),\"End duration date must be later than start duration date.\"))\n  \n  # create date intervals\n  dseq <- seq(as.Date(input$in_duration_date_start),as.Date(input$in_duration_date_end),by=1)\n  r1 <- unique(as.character(cut(dseq,breaks=3)))\n  \n  updateDateInput(session,\"in_track_date_start_1\",label=\"From\",value=as.Date(r1[1],\"%Y-%m-%d\"))\n  updateDateInput(session,\"in_track_date_end_1\",label=\"To\",value=as.Date(r1[1+1],\"%Y-%m-%d\")-1)\n  updateDateInput(session,\"in_track_date_start_2\",label=\"From\",value=as.Date(r1[2],\"%Y-%m-%d\"))\n  updateDateInput(session,\"in_track_date_end_2\",label=\"To\",value=as.Date(r1[2+1],\"%Y-%m-%d\")-1)\n  \n})\n```\n:::\n\n\nThe complete code for the app is as below.\n\n\n::: {.cell}\n\n```{.r .cell-code}\n## load libraries\nlibrary(ggplot2)\nlibrary(shiny)\nlibrary(colourpicker)\n\n## load colours\ncols <- toupper(c(\n  \"#bebada\",\"#fb8072\",\"#80b1d3\",\"#fdb462\",\"#b3de69\",\"#fccde5\",\"#FDBF6F\",\"#A6CEE3\",\n  \"#56B4E9\",\"#B2DF8A\",\"#FB9A99\",\"#CAB2D6\",\"#A9C4E2\",\"#79C360\",\"#FDB762\",\"#9471B4\",\n  \"#A4A4A4\",\"#fbb4ae\",\"#b3cde3\",\"#ccebc5\",\"#decbe4\",\"#fed9a6\",\"#ffffcc\",\"#e5d8bd\",\n  \"#fddaec\",\"#f2f2f2\",\"#8dd3c7\",\"#d9d9d9\"))\n\nshinyApp(\n\n# UI ---------------------------------------------------------------------------\n\nui=fluidPage(\n  pageWithSidebar(\n    headerPanel(title=\"Calendar Planner\",windowTitle=\"Calendar Planner\"),\n    sidebarPanel(\n      h3(\"Duration\"),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              dateInput(\"in_duration_date_start\",\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              dateInput(\"in_duration_date_end\",\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          )\n      ),\n      h3(\"Tracks\"),\n      fluidRow(\n          column(3,style=list(\"padding-right: 3px;\"),\n              textInput(\"in_track_name_1\",label=\"Name\",value=\"Vacation\",placeholder=\"Vacation\")\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n              dateInput(\"in_track_date_start_1\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n              dateInput(\"in_track_date_end_1\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-left: 3px;\"),\n              colourpicker::colourInput(\"in_track_colour_1\",label=\"Colour\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[1])\n          )\n      ),\n      fluidRow(\n          column(3,style=list(\"padding-right: 3px;\"),\n              textInput(\"in_track_name_2\",label=\"Name\",value=\"Offline\",placeholder=\"Offline\")\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n              dateInput(\"in_track_date_start_2\",label=\"From\",value=format(Sys.time(),\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-right: 3px; padding-left: 3px;\"),\n              dateInput(\"in_track_date_end_2\",label=\"To\",value=format(as.Date(Sys.time())+30,\"%Y-%m-%d\"))\n          ),\n          column(3,style=list(\"padding-left: 3px;\"),\n              colourpicker::colourInput(\"in_track_colour_2\",label=\"Colour\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[2])\n          )\n      ),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              colourpicker::colourInput(\"in_track_colour_available\",label=\"Track colour (Available)\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[length(cols)-1])\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              colourpicker::colourInput(\"in_track_colour_weekend\",label=\"Track colour (Weekend)\",\n                                        palette=\"limited\",allowedCols=cols,value=cols[length(cols)])\n          )\n      ),\n      tags$br(),\n      h3(\"Settings\"),\n      selectInput(\"in_legend_position\",label=\"Legend position\",\n                  choices=c(\"top\",\"right\",\"left\",\"bottom\"),selected=\"right\",multiple=F),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              selectInput(\"in_legend_justification\",label=\"Legend justification\",\n                          choices=c(\"left\",\"right\"),selected=\"right\",multiple=F)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              selectInput(\"in_legend_direction\",label=\"Legend direction\",\n                          choices=c(\"vertical\",\"horizontal\"),selected=\"vertical\",multiple=F)\n          )\n      ),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              numericInput(\"in_themefontsize\",label=\"Theme font size\",value=8,step=0.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              numericInput(\"in_datefontsize\",label=\"Date font size\",value=2.5,step=0.1)\n          )\n      ),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              numericInput(\"in_monthfontsize\",label=\"Month font size\",value=8,step=0.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              numericInput(\"in_legendfontsize\",label=\"Legend font size\",value=5,step=0.5)\n          )\n      ),\n      tags$br(),\n      h3(\"Download\"),\n      helpText(\"Width is automatically calculated based on the number of weeks. File type is only applicable to download and does not change preview.\"),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              numericInput(\"in_height\",\"Height (cm)\",step=0.5,value=5.5)\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              numericInput(\"in_width\",\"Width (cm)\",step=0.5,value=NA)\n          )\n      ),\n      fluidRow(\n          column(6,style=list(\"padding-right: 5px;\"),\n              selectInput(\"in_res\",\"Res/DPI\",choices=c(\"200\",\"300\",\"400\",\"500\"),selected=\"200\")\n          ),\n          column(6,style=list(\"padding-left: 5px;\"),\n              selectInput(\"in_format\",\"File type\",choices=c(\"png\",\"tiff\",\"jpeg\",\"pdf\"),selected=\"png\",multiple=FALSE,selectize=TRUE)\n          )\n      ),\n      downloadButton(\"btn_downloadplot\",\"Download Plot\"),\n      tags$hr(),\n      helpText(\"RaukR\")\n    ),\n    mainPanel(\n      sliderInput(\"in_scale\",\"Image preview scale\",min=0.1,max=3,step=0.10,value=1),\n      helpText(\"Scale only controls preview here and does not affect download.\"),\n      tags$br(),\n      imageOutput(\"out_plot\")\n    )\n  )\n),\n\n# SERVER -----------------------------------------------------------------------\n\nserver=function(input, output, session) {\n\n  store <- reactiveValues(week=NULL)\n\n  ## RFN: fn_plot -----------------------------------------------------------\n  ## core plotting function, returns a ggplot object\n\n  fn_plot <- reactive({\n\n    shiny::req(input$in_duration_date_start)\n    shiny::req(input$in_duration_date_end)\n\n    shiny::req(input$in_track_date_start_1)\n    shiny::req(input$in_track_date_end_1)\n    shiny::req(input$in_track_name_1)\n    shiny::req(input$in_track_colour_1)\n\n    shiny::req(input$in_track_date_start_2)\n    shiny::req(input$in_track_date_end_2)\n    shiny::req(input$in_track_name_2)\n    shiny::req(input$in_track_colour_2)\n\n    shiny::req(input$in_legend_position)\n    shiny::req(input$in_legend_justification)\n    shiny::req(input$in_legend_direction)\n    shiny::req(input$in_themefontsize)\n    shiny::req(input$in_datefontsize)\n    shiny::req(input$in_monthfontsize)\n    shiny::req(input$in_legendfontsize)\n\n    validate(need(input$in_track_name_1!=input$in_track_name_2,\"Duplicate track names are not allowed.\"))\n    validate(need(as.Date(input$in_duration_date_start) < as.Date(input$in_duration_date_end),\"End duration date must be later than start duration date.\"))\n\n    # prepare dates\n    dfr <- data.frame(date=seq(as.Date(input$in_duration_date_start),as.Date(input$in_duration_date_end),by=1))\n    dfr$day <- factor(strftime(dfr$date,format=\"%a\"),levels=rev(c(\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\")))\n    dfr$week <- factor(strftime(dfr$date,format=\"%V\"))\n    dfr$month <- strftime(dfr$date,format=\"%B\")\n    dfr$month <- factor(dfr$month,levels=unique(dfr$month))\n    dfr$ddate <- factor(strftime(dfr$date,format=\"%d\"))\n\n    #add tracks\n    dfr$track <- \"Available\"\n    dfr$track[dfr$day==\"Sat\" | dfr$day==\"Sun\"] <- \"Weekend\"\n\n    temp_start_date_1 <- as.Date(input$in_track_date_start_1)\n    temp_end_date_1 <- as.Date(input$in_track_date_end_1)\n    temp_track_name_1 <- input$in_track_name_1\n    temp_track_col_1 <- input$in_track_colour_1\n    validate(need(temp_start_date_1 < temp_end_date_1,\"End track duration date must be later than start track duration date.\"))\n    dfr$track[dfr$date>=temp_start_date_1 & dfr$date<=temp_end_date_1] <- temp_track_name_1\n\n    temp_start_date_2 <- as.Date(input$in_track_date_start_2)\n    temp_end_date_2 <- as.Date(input$in_track_date_end_2)\n    temp_track_name_2 <- input$in_track_name_2\n    temp_track_col_2 <- input$in_track_colour_2\n    validate(need(temp_start_date_2 < temp_end_date_2,\"End track duration date must be later than start track duration date.\"))\n    dfr$track[dfr$date>=temp_start_date_2 & dfr$date<=temp_end_date_2] <- temp_track_name_2\n\n    # create order factor\n    fc <- vector(mode=\"character\")\n    if(\"Available\" %in% unique(dfr$track)) fc <- c(fc,\"Available\")\n    fc <- c(fc,temp_track_name_1,temp_track_name_2)\n    if(\"Weekend\" %in% unique(dfr$track)) fc <- c(fc,\"Weekend\")\n    dfr$track <- factor(dfr$track,levels=fc)\n\n    # prepare colours\n    all_cols <- c(input$in_track_colour_available,temp_track_col_1,temp_track_col_2,input$in_track_colour_weekend)\n\n    # plot\n    p <- ggplot(dfr,aes(x=week,y=day))+\n      geom_tile(aes(fill=track))+\n      geom_text(aes(label=ddate),size=input$in_datefontsize)+\n      scale_fill_manual(values=all_cols)+\n      facet_grid(~month,scales=\"free\",space=\"free\")+\n      labs(x=\"Week\",y=\"\")+\n      theme_bw(base_size=input$in_themefontsize)+\n      theme(legend.title=element_blank(),\n            panel.grid=element_blank(),\n            panel.border=element_blank(),\n            axis.ticks=element_blank(),\n            axis.title=element_text(colour=\"grey30\"),\n            strip.background=element_blank(),\n            strip.text=element_text(size=input$in_monthfontsize),\n            legend.position=input$in_legend_position,\n            legend.justification=input$in_legend_justification,\n            legend.direction=input$in_legend_direction,\n            legend.text=element_text(size=input$in_legendfontsize),\n            legend.key.size=unit(0.3,\"cm\"),\n            legend.spacing.x=unit(0.2,\"cm\"))\n\n    # add number of weeks to reactive value\n    store$week <- length(levels(dfr$week))\n\n    return(p)\n  })\n\n  ## OUT: out_plot ------------------------------------------------------------\n  ## plots figure\n\n  output$out_plot <- renderImage({\n\n    shiny::req(fn_plot())\n    shiny::req(input$in_height)\n    shiny::req(input$in_res)\n    shiny::req(input$in_scale)\n\n    height <- as.numeric(input$in_height)\n    width <- as.numeric(input$in_width)\n    res <- as.numeric(input$in_res)\n\n    if(is.na(width)) {\n      width <- (store$week*1.2)\n      if(width < 4.5) width <- 4.5\n    }\n\n    p <- fn_plot()\n    ggsave(\"calendar_plot.png\",p,height=height,width=width,units=\"cm\",dpi=res)\n\n    return(list(src=\"calendar_plot.png\",\n                contentType=\"image/png\",\n                width=round(((width*res)/2.54)*input$in_scale,0),\n                height=round(((height*res)/2.54)*input$in_scale,0),\n                alt=\"calendar_plot\"))\n  }, deleteFile=TRUE)\n\n  # FN: fn_downloadplotname ----------------------------------------------------\n  # creates filename for download plot\n\n  fn_downloadplotname <- function()\n  {\n    return(paste0(\"calendar_plot.\",input$in_format))\n  }\n\n  ## FN: fn_downloadplot -------------------------------------------------\n  ## function to download plot\n\n  fn_downloadplot <- function(){\n    shiny::req(fn_plot())\n    shiny::req(input$in_height)\n    shiny::req(input$in_res)\n    shiny::req(input$in_scale)\n\n    height <- as.numeric(input$in_height)\n    width <- as.numeric(input$in_width)\n    res <- as.numeric(input$in_res)\n    format <- input$in_format\n\n    if(is.na(width)) width <- (store$week*1)+1\n\n    p <- fn_plot()\n    if(format==\"pdf\" | format==\"svg\"){\n      ggsave(fn_downloadplotname(),p,height=height,width=width,units=\"cm\",dpi=res)\n      #embed_fonts(fn_downloadplotname())\n    }else{\n      ggsave(fn_downloadplotname(),p,height=height,width=width,units=\"cm\",dpi=res)\n\n    }\n  }\n\n  ## DHL: btn_downloadplot ----------------------------------------------------\n  ## download handler for downloading plot\n\n  output$btn_downloadplot <- downloadHandler(\n    filename=fn_downloadplotname,\n    content=function(file) {\n      fn_downloadplot()\n      file.copy(fn_downloadplotname(),file,overwrite=T)\n    }\n  )\n\n  ## OBS: tracks dates ---------------------------------------------------------\n  \n  observe({\n    \n    shiny::req(input$in_duration_date_start)\n    shiny::req(input$in_duration_date_end)\n    \n    validate(need(as.Date(input$in_duration_date_start) < as.Date(input$in_duration_date_end),\"End duration date must be later than start duration date.\"))\n    \n    # create date intervals\n    dseq <- seq(as.Date(input$in_duration_date_start),as.Date(input$in_duration_date_end),by=1)\n    r1 <- unique(as.character(cut(dseq,breaks=3)))\n    \n    updateDateInput(session,\"in_track_date_start_1\",label=\"From\",value=as.Date(r1[1],\"%Y-%m-%d\"))\n    updateDateInput(session,\"in_track_date_end_1\",label=\"To\",value=as.Date(r1[1+1],\"%Y-%m-%d\")-1)\n    updateDateInput(session,\"in_track_date_start_2\",label=\"From\",value=as.Date(r1[2],\"%Y-%m-%d\"))\n    updateDateInput(session,\"in_track_date_end_2\",label=\"To\",value=as.Date(r1[2+1],\"%Y-%m-%d\")-1)\n    \n  })\n})\n```\n:::\n\n\n![](assets/calendar-preview.png)\n\nHopefully, this has not been too overwhelming. Shiny app code may look over-complicated on the first look, but it is easier to understand what is happening by breaking it apart into smaller chunks and understanding how the various components are connected. It is crucial to plan out the structure of your app well in advanced as it is easy to get confused. Remember to name functions and variables sensibly. Use text output widgets and/or print statements in the code to keep track of internal variable values during run-time. Go forth and build awesome apps!\n",
    "supporting": [
      "index_files"
    ],
    "filters": [
      "rmarkdown/pagebreak.lua"
    ],
    "includes": {},
    "engineDependencies": {},
    "preserve": {},
    "postProcess": true
  }
}